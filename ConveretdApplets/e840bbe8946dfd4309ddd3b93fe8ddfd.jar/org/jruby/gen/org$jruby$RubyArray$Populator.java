// 
// Decompiled by Procyon v0.5.30
// 

package org.jruby.gen;

import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.Ruby;
import org.jruby.RubyClass;
import org.jruby.RubyArray$i$flatten19;
import org.jruby.RubyArray$i$join19;
import org.jruby.RubyArray$i$0$0$push_m19;
import org.jruby.RubyArray$i$1$0$pack19;
import org.jruby.RubyArray$i$1$0$repeatedCombination;
import org.jruby.RubyArray$i$0$0$select_bang;
import org.jruby.RubyArray$i$1$0$drop;
import org.jruby.RubyArray$i$flatten_bang19;
import org.jruby.RubyArray$i$rotate_bang;
import org.jruby.RubyArray$i$0$0$hash19;
import org.jruby.RubyArray$i$repeated_permutation;
import org.jruby.RubyArray$i$1$0$take;
import org.jruby.RubyArray$i$aref19;
import org.jruby.RubyArray$i$0$1$shuffle_bang;
import org.jruby.RubyArray$i$0$0$uniq19;
import org.jruby.RubyArray$i$1$0$op_times19;
import org.jruby.RubyArray$i$insert19;
import org.jruby.RubyArray$i$0$0$uniq_bang19;
import org.jruby.RubyArray$i$1$0$concat19;
import org.jruby.RubyArray$i$0$0$keep_if;
import org.jruby.RubyArray$i$0$0$drop_while;
import org.jruby.RubyArray$i$rotate;
import org.jruby.RubyArray$i$aset19;
import org.jruby.RubyArray$i$0$1$shuffle;
import org.jruby.RubyArray$i$sample;
import org.jruby.RubyArray$i$unshift19;
import org.jruby.RubyArray$i$0$0$collect19;
import org.jruby.RubyArray$i$0$0$sort19;
import org.jruby.RubyArray$i$0$0$take_while;
import org.jruby.RubyArray$i$0$0$sort_by_bang;
import org.jruby.RubyArray$i$0$0$sort_bang19;
import org.jruby.RubyArray$i$0$0$product19;
import org.jruby.RubyArray$i$flatten;
import org.jruby.RubyArray$i$0$0$uniq;
import org.jruby.RubyArray$i$1$0$op_times;
import org.jruby.RubyArray$i$join;
import org.jruby.RubyArray$i$insert;
import org.jruby.RubyArray$i$0$0$uniq_bang;
import org.jruby.RubyArray$i$0$0$push_m;
import org.jruby.RubyArray$i$1$0$concat;
import org.jruby.RubyString;
import org.jruby.RubyArray$i$1$0$pack;
import org.jruby.RubyArray$i$flatten_bang;
import org.jruby.RubyArray$i$aset;
import org.jruby.RubyArray$i$0$0$hash;
import org.jruby.RubyArray$i$aref;
import org.jruby.RubyArray$i$0$0$shuffle_bang;
import org.jruby.RubyArray$i$0$0$choice;
import org.jruby.RubyArray$i$0$0$shuffle;
import org.jruby.RubyArray$i$0$0$collect;
import org.jruby.RubyArray$i$unshift;
import org.jruby.RubyArray$i$0$0$sort;
import org.jruby.RubyArray$i$0$0$sort_bang;
import org.jruby.RubyArray$i$0$0$product;
import org.jruby.RubyArray$i$count;
import org.jruby.RubyArray$i$permutation;
import org.jruby.RubyArray$i$1$0$initialize_copy;
import org.jruby.RubyArray$i$0$0$to_ary;
import org.jruby.RubyArray$i$0$0$collect_bang;
import org.jruby.RubyArray$i$0$0$reverse;
import org.jruby.RubyArray$i$0$0$inspect;
import org.jruby.RubyArray$i$1$0$op_diff;
import org.jruby.RubyArray$i$0$0$reverse_bang;
import org.jruby.RubyArray$i$1$0$at;
import org.jruby.RubyArray$i$cycle;
import org.jruby.RubyArray$i$1$0$delete;
import org.jruby.RubyArray$i$0$0$reject_bang;
import org.jruby.RubyArray$i$1$0$delete_at;
import org.jruby.RubyFixnum;
import org.jruby.RubyArray$i$0$0$length;
import org.jruby.RubyArray$i$1$0$replace;
import org.jruby.RubyArray$i$pop;
import org.jruby.RubyArray$i$0$0$insert;
import org.jruby.RubyArray$i$0$0$indexes;
import org.jruby.RubyArray$i$rindex;
import org.jruby.RubyArray$i$0$0$to_s;
import org.jruby.RubyArray$i$1$0$op_equal;
import org.jruby.RubyArray$i$fetch;
import org.jruby.RubyArray$i$1$0$assoc;
import org.jruby.RubyArray$i$0$0$transpose;
import org.jruby.RubyArray$i$1$0$rassoc;
import org.jruby.RubyArray$i$index;
import org.jruby.RubyArray$i$0$0$compact;
import org.jruby.RubyArray$i$0$0$reverse_each;
import org.jruby.RubyArray$i$0$0$values_at;
import org.jruby.RubyArray$i$1$0$op_and;
import org.jruby.RubyArray$i$shift;
import org.jruby.RubyArray$i$1$0$append;
import org.jruby.RubyArray$i$last;
import org.jruby.RubyArray$i$0$0$reject;
import org.jruby.RubyArray$i$initialize;
import org.jruby.RubyArray$i$0$0$select;
import org.jruby.RubyArray$i$0$0$nitems;
import org.jruby.RubyArray$i$first;
import org.jruby.RubyArray$i$0$0$to_a;
import org.jruby.RubyArray$i$1$0$include_p;
import org.jruby.RubyArray$i$0$0$each_index;
import org.jruby.RubyArray$i$0$1$zip;
import org.jruby.RubyArray$i$0$0$compact_bang;
import org.jruby.RubyArray$i$0$0$rb_clear;
import org.jruby.RubyArray$i$0$0$empty_p;
import org.jruby.RubyArray$i$slice_bang;
import org.jruby.RubyArray$i$0$0$delete_if;
import org.jruby.RubyArray$i$1$0$op_or;
import org.jruby.RubyArray$i$1$0$eql;
import org.jruby.RubyArray$i$0$0$each;
import org.jruby.RubyArray$i$1$0$op_cmp;
import org.jruby.RubyArray$i$1$0$each_slice;
import org.jruby.RubyArray$i$fill;
import org.jruby.RubyArray$i$0$0$map_bang;
import org.jruby.RubyArray$i$1$0$op_plus;
import org.jruby.RubyArray$i$1$0$combination;
import org.jruby.RubyBoolean;
import org.jruby.RubyArray$i$0$0$frozen_p;
import org.jruby.runtime.ThreadContext;
import org.jruby.RubyArray$s$1$0$try_convert;
import org.jruby.CompatVersion;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.runtime.Block;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.RubyArray;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.RubyArray$s$0$0$create;
import org.jruby.runtime.Visibility;
import org.jruby.RubyModule;
import org.jruby.anno.TypePopulator;

public class org$jruby$RubyArray$Populator extends TypePopulator
{
    public void populate(final RubyModule cls, final Class clazz) {
        final RubyClass singletonClass = cls.getSingletonClass();
        final CompatVersion compatVersion = cls.getRuntime().getInstanceConfig().getCompatVersion();
        final Ruby runtime = cls.getRuntime();
        JavaMethod javaMethod = new RubyArray$s$0$0$create(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "create", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "create", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject[].class, Block.class }, true);
        singletonClass.addMethodAtBootTimeOnly("[]", javaMethod);
        runtime.addBoundMethod("org.jruby.RubyArray.create", "[]");
        if (compatVersion == CompatVersion.RUBY1_9 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyArray$s$1$0$try_convert(singletonClass, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "try_convert", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "try_convert", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            singletonClass.addMethodAtBootTimeOnly("try_convert", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyArray.try_convert", "try_convert");
        }
        javaMethod = new RubyArray$i$0$0$frozen_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "frozen_p", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "frozen_p", RubyBoolean.class, new Class[] { ThreadContext.class }, false);
        cls.addMethodAtBootTimeOnly("frozen?", javaMethod);
        javaMethod = new RubyArray$i$1$0$combination(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "combination", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "combination", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("combination", javaMethod);
        javaMethod = new RubyArray$i$1$0$op_plus(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_plus", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "op_plus", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("+", javaMethod);
        javaMethod = new RubyArray$i$0$0$map_bang(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "map_bang", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "map_bang", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("map!", javaMethod);
        javaMethod = new RubyArray$i$fill(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "fill", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("fill", javaMethod);
        javaMethod = new RubyArray$i$1$0$each_slice(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "each_slice", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "each_slice", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("each_slice", javaMethod);
        javaMethod = new RubyArray$i$1$0$op_cmp(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_cmp", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "op_cmp", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("<=>", javaMethod);
        javaMethod = new RubyArray$i$0$0$each(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "each", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "each", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("each", javaMethod);
        javaMethod = new RubyArray$i$1$0$eql(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "eql", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "eql", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("eql?", javaMethod);
        javaMethod = new RubyArray$i$1$0$op_or(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_or", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "op_or", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("|", javaMethod);
        javaMethod = new RubyArray$i$0$0$delete_if(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "delete_if", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "delete_if", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("delete_if", javaMethod);
        javaMethod = new RubyArray$i$slice_bang(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "slice_bang", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("slice!", javaMethod);
        javaMethod = new RubyArray$i$0$0$empty_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "empty_p", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "empty_p", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("empty?", javaMethod);
        javaMethod = new RubyArray$i$0$0$rb_clear(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "rb_clear", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "rb_clear", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("clear", javaMethod);
        javaMethod = new RubyArray$i$0$0$compact_bang(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "compact_bang", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "compact_bang", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("compact!", javaMethod);
        javaMethod = new RubyArray$i$0$1$zip(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "zip", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "zip", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject[].class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("zip", javaMethod);
        javaMethod = new RubyArray$i$0$0$each_index(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "each_index", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "each_index", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("each_index", javaMethod);
        javaMethod = new RubyArray$i$1$0$include_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "include_p", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "include_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("include?", javaMethod);
        javaMethod = new RubyArray$i$0$0$to_a(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "to_a", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "to_a", RubyArray.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("to_a", javaMethod);
        javaMethod = new RubyArray$i$first(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "first", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("first", javaMethod);
        javaMethod = new RubyArray$i$0$0$nitems(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "nitems", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "nitems", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("nitems", javaMethod);
        javaMethod = new RubyArray$i$0$0$select(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "select", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "select", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("select", javaMethod);
        javaMethod = new RubyArray$i$initialize(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "initialize", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("initialize", javaMethod);
        javaMethod = new RubyArray$i$0$0$reject(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "reject", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "reject", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("reject", javaMethod);
        javaMethod = new RubyArray$i$last(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "last", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("last", javaMethod);
        javaMethod = new RubyArray$i$1$0$append(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "append", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "append", RubyArray.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("<<", javaMethod);
        javaMethod = new RubyArray$i$shift(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "shift", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("shift", javaMethod);
        javaMethod = new RubyArray$i$1$0$op_and(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_and", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "op_and", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("&", javaMethod);
        javaMethod = new RubyArray$i$0$0$values_at(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "values_at", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "values_at", IRubyObject.class, new Class[] { IRubyObject[].class }, false);
        cls.addMethodAtBootTimeOnly("values_at", javaMethod);
        javaMethod = new RubyArray$i$0$0$reverse_each(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "reverse_each", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "reverse_each", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("reverse_each", javaMethod);
        javaMethod = new RubyArray$i$0$0$compact(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "compact", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "compact", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("compact", javaMethod);
        javaMethod = new RubyArray$i$index(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "index", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("index", javaMethod);
        cls.addMethodAtBootTimeOnly("find_index", javaMethod);
        javaMethod = new RubyArray$i$1$0$rassoc(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "rassoc", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "rassoc", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("rassoc", javaMethod);
        javaMethod = new RubyArray$i$0$0$transpose(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "transpose", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "transpose", RubyArray.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("transpose", javaMethod);
        javaMethod = new RubyArray$i$1$0$assoc(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "assoc", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "assoc", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("assoc", javaMethod);
        javaMethod = new RubyArray$i$fetch(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "fetch", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("fetch", javaMethod);
        javaMethod = new RubyArray$i$1$0$op_equal(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_equal", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "op_equal", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("==", javaMethod);
        javaMethod = new RubyArray$i$0$0$to_s(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "to_s", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "to_s", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("to_s", javaMethod);
        javaMethod = new RubyArray$i$rindex(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "rindex", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("rindex", javaMethod);
        javaMethod = new RubyArray$i$0$0$indexes(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "indexes", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "indexes", IRubyObject.class, new Class[] { IRubyObject[].class }, false);
        cls.addMethodAtBootTimeOnly("indexes", javaMethod);
        cls.addMethodAtBootTimeOnly("indices", javaMethod);
        javaMethod = new RubyArray$i$0$0$insert(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "insert", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "insert", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("insert", javaMethod);
        javaMethod = new RubyArray$i$pop(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "pop", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("pop", javaMethod);
        javaMethod = new RubyArray$i$1$0$replace(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "replace", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "replace", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("replace", javaMethod);
        javaMethod = new RubyArray$i$0$0$length(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "length", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "length", RubyFixnum.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("length", javaMethod);
        cls.defineAlias("size", "length");
        javaMethod = new RubyArray$i$1$0$delete_at(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "delete_at", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "delete_at", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("delete_at", javaMethod);
        javaMethod = new RubyArray$i$0$0$reject_bang(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "reject_bang", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "reject_bang", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("reject!", javaMethod);
        javaMethod = new RubyArray$i$1$0$delete(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "delete", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "delete", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("delete", javaMethod);
        javaMethod = new RubyArray$i$cycle(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "cycle", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("cycle", javaMethod);
        javaMethod = new RubyArray$i$1$0$at(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "at", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "at", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("at", javaMethod);
        javaMethod = new RubyArray$i$0$0$reverse_bang(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "reverse_bang", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "reverse_bang", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("reverse!", javaMethod);
        javaMethod = new RubyArray$i$1$0$op_diff(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_diff", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "op_diff", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("-", javaMethod);
        javaMethod = new RubyArray$i$0$0$inspect(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "inspect", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "inspect", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("inspect", javaMethod);
        javaMethod = new RubyArray$i$0$0$reverse(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "reverse", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "reverse", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("reverse", javaMethod);
        javaMethod = new RubyArray$i$0$0$collect_bang(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "collect_bang", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "collect_bang", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("collect!", javaMethod);
        javaMethod = new RubyArray$i$0$0$to_ary(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "to_ary", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "to_ary", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("to_ary", javaMethod);
        javaMethod = new RubyArray$i$1$0$initialize_copy(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "initialize_copy", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyArray.class, "initialize_copy", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("initialize_copy", javaMethod);
        javaMethod = new RubyArray$i$permutation(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "permutation", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("permutation", javaMethod);
        javaMethod = new RubyArray$i$count(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "count", false, CallConfiguration.FrameNoneScopeNone, false);
        cls.addMethodAtBootTimeOnly("count", javaMethod);
        runtime.addBoundMethod("org.jruby.RubyArray.frozen_p", "frozen?");
        runtime.addBoundMethod("org.jruby.RubyArray.combination", "combination");
        runtime.addBoundMethod("org.jruby.RubyArray.op_plus", "+");
        runtime.addBoundMethod("org.jruby.RubyArray.map_bang", "map!");
        runtime.addBoundMethod("org.jruby.RubyArray.fill", "fill");
        runtime.addBoundMethod("org.jruby.RubyArray.each_slice", "each_slice");
        runtime.addBoundMethod("org.jruby.RubyArray.op_cmp", "<=>");
        runtime.addBoundMethod("org.jruby.RubyArray.each", "each");
        runtime.addBoundMethod("org.jruby.RubyArray.eql", "eql?");
        runtime.addBoundMethod("org.jruby.RubyArray.op_or", "|");
        runtime.addBoundMethod("org.jruby.RubyArray.delete_if", "delete_if");
        runtime.addBoundMethod("org.jruby.RubyArray.slice_bang", "slice!");
        runtime.addBoundMethod("org.jruby.RubyArray.empty_p", "empty?");
        runtime.addBoundMethod("org.jruby.RubyArray.rb_clear", "clear");
        runtime.addBoundMethod("org.jruby.RubyArray.compact_bang", "compact!");
        runtime.addBoundMethod("org.jruby.RubyArray.zip", "zip");
        runtime.addBoundMethod("org.jruby.RubyArray.each_index", "each_index");
        runtime.addBoundMethod("org.jruby.RubyArray.include_p", "include?");
        runtime.addBoundMethod("org.jruby.RubyArray.to_a", "to_a");
        runtime.addBoundMethod("org.jruby.RubyArray.first", "first");
        runtime.addBoundMethod("org.jruby.RubyArray.nitems", "nitems");
        runtime.addBoundMethod("org.jruby.RubyArray.select", "select");
        runtime.addBoundMethod("org.jruby.RubyArray.initialize", "initialize");
        runtime.addBoundMethod("org.jruby.RubyArray.reject", "reject");
        runtime.addBoundMethod("org.jruby.RubyArray.last", "last");
        runtime.addBoundMethod("org.jruby.RubyArray.append", "<<");
        runtime.addBoundMethod("org.jruby.RubyArray.shift", "shift");
        runtime.addBoundMethod("org.jruby.RubyArray.op_and", "&");
        runtime.addBoundMethod("org.jruby.RubyArray.values_at", "values_at");
        runtime.addBoundMethod("org.jruby.RubyArray.reverse_each", "reverse_each");
        runtime.addBoundMethod("org.jruby.RubyArray.compact", "compact");
        runtime.addBoundMethod("org.jruby.RubyArray.index", "index");
        runtime.addBoundMethod("org.jruby.RubyArray.rassoc", "rassoc");
        runtime.addBoundMethod("org.jruby.RubyArray.transpose", "transpose");
        runtime.addBoundMethod("org.jruby.RubyArray.assoc", "assoc");
        runtime.addBoundMethod("org.jruby.RubyArray.fetch", "fetch");
        runtime.addBoundMethod("org.jruby.RubyArray.op_equal", "==");
        runtime.addBoundMethod("org.jruby.RubyArray.to_s", "to_s");
        runtime.addBoundMethod("org.jruby.RubyArray.rindex", "rindex");
        runtime.addBoundMethod("org.jruby.RubyArray.indexes", "indexes");
        runtime.addBoundMethod("org.jruby.RubyArray.insert", "insert");
        runtime.addBoundMethod("org.jruby.RubyArray.pop", "pop");
        runtime.addBoundMethod("org.jruby.RubyArray.replace", "replace");
        runtime.addBoundMethod("org.jruby.RubyArray.length", "length");
        runtime.addBoundMethod("org.jruby.RubyArray.delete_at", "delete_at");
        runtime.addBoundMethod("org.jruby.RubyArray.reject_bang", "reject!");
        runtime.addBoundMethod("org.jruby.RubyArray.delete", "delete");
        runtime.addBoundMethod("org.jruby.RubyArray.cycle", "cycle");
        runtime.addBoundMethod("org.jruby.RubyArray.at", "at");
        runtime.addBoundMethod("org.jruby.RubyArray.reverse_bang", "reverse!");
        runtime.addBoundMethod("org.jruby.RubyArray.op_diff", "-");
        runtime.addBoundMethod("org.jruby.RubyArray.inspect", "inspect");
        runtime.addBoundMethod("org.jruby.RubyArray.reverse", "reverse");
        runtime.addBoundMethod("org.jruby.RubyArray.collect_bang", "collect!");
        runtime.addBoundMethod("org.jruby.RubyArray.to_ary", "to_ary");
        runtime.addBoundMethod("org.jruby.RubyArray.initialize_copy", "initialize_copy");
        runtime.addBoundMethod("org.jruby.RubyArray.permutation", "permutation");
        runtime.addBoundMethod("org.jruby.RubyArray.count", "count");
        if (compatVersion == CompatVersion.RUBY1_8 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyArray$i$0$0$product(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "product", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "product", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject[].class }, false);
            cls.addMethodAtBootTimeOnly("product", javaMethod);
            javaMethod = new RubyArray$i$0$0$sort_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "sort_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "sort_bang", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("sort!", javaMethod);
            javaMethod = new RubyArray$i$0$0$sort(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "sort", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "sort", RubyArray.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("sort", javaMethod);
            javaMethod = new RubyArray$i$unshift(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "unshift", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("unshift", javaMethod);
            javaMethod = new RubyArray$i$0$0$collect(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "collect", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "collect", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("collect", javaMethod);
            cls.addMethodAtBootTimeOnly("map", javaMethod);
            javaMethod = new RubyArray$i$0$0$shuffle(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "shuffle", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "shuffle", IRubyObject.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("shuffle", javaMethod);
            javaMethod = new RubyArray$i$0$0$choice(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "choice", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "choice", IRubyObject.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("choice", javaMethod);
            javaMethod = new RubyArray$i$0$0$shuffle_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "shuffle_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "shuffle_bang", IRubyObject.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("shuffle!", javaMethod);
            javaMethod = new RubyArray$i$aref(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "aref", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("[]", javaMethod);
            cls.addMethodAtBootTimeOnly("slice", javaMethod);
            javaMethod = new RubyArray$i$0$0$hash(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "hash", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "hash", RubyFixnum.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("hash", javaMethod);
            javaMethod = new RubyArray$i$aset(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "aset", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("[]=", javaMethod);
            javaMethod = new RubyArray$i$flatten_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "flatten_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("flatten!", javaMethod);
            javaMethod = new RubyArray$i$1$0$pack(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "pack", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "pack", RubyString.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("pack", javaMethod);
            javaMethod = new RubyArray$i$1$0$concat(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "concat", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "concat", RubyArray.class, new Class[] { IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("concat", javaMethod);
            javaMethod = new RubyArray$i$0$0$push_m(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "push_m", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "push_m", RubyArray.class, new Class[] { IRubyObject[].class }, false);
            cls.addMethodAtBootTimeOnly("push", javaMethod);
            javaMethod = new RubyArray$i$0$0$uniq_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "uniq_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "uniq_bang", IRubyObject.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("uniq!", javaMethod);
            javaMethod = new RubyArray$i$insert(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "insert", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("insert", javaMethod);
            javaMethod = new RubyArray$i$join(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "join", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("join", javaMethod);
            javaMethod = new RubyArray$i$1$0$op_times(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_times", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "op_times", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("*", javaMethod);
            javaMethod = new RubyArray$i$0$0$uniq(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "uniq", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "uniq", IRubyObject.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("uniq", javaMethod);
            javaMethod = new RubyArray$i$flatten(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "flatten", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("flatten", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyArray.product", "product");
            runtime.addBoundMethod("org.jruby.RubyArray.sort_bang", "sort!");
            runtime.addBoundMethod("org.jruby.RubyArray.sort", "sort");
            runtime.addBoundMethod("org.jruby.RubyArray.unshift", "unshift");
            runtime.addBoundMethod("org.jruby.RubyArray.collect", "collect");
            runtime.addBoundMethod("org.jruby.RubyArray.shuffle", "shuffle");
            runtime.addBoundMethod("org.jruby.RubyArray.choice", "choice");
            runtime.addBoundMethod("org.jruby.RubyArray.shuffle_bang", "shuffle!");
            runtime.addBoundMethod("org.jruby.RubyArray.aref", "[]");
            runtime.addBoundMethod("org.jruby.RubyArray.hash", "hash");
            runtime.addBoundMethod("org.jruby.RubyArray.aset", "[]=");
            runtime.addBoundMethod("org.jruby.RubyArray.flatten_bang", "flatten!");
            runtime.addBoundMethod("org.jruby.RubyArray.pack", "pack");
            runtime.addBoundMethod("org.jruby.RubyArray.concat", "concat");
            runtime.addBoundMethod("org.jruby.RubyArray.push_m", "push");
            runtime.addBoundMethod("org.jruby.RubyArray.uniq_bang", "uniq!");
            runtime.addBoundMethod("org.jruby.RubyArray.insert", "insert");
            runtime.addBoundMethod("org.jruby.RubyArray.join", "join");
            runtime.addBoundMethod("org.jruby.RubyArray.op_times", "*");
            runtime.addBoundMethod("org.jruby.RubyArray.uniq", "uniq");
            runtime.addBoundMethod("org.jruby.RubyArray.flatten", "flatten");
        }
        if (compatVersion == CompatVersion.RUBY1_9 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyArray$i$0$0$product19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "product19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "product19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject[].class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("product", javaMethod);
            javaMethod = new RubyArray$i$0$0$sort_bang19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "sort_bang19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "sort_bang19", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("sort!", javaMethod);
            javaMethod = new RubyArray$i$0$0$sort_by_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "sort_by_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "sort_by_bang", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("sort_by!", javaMethod);
            javaMethod = new RubyArray$i$0$0$take_while(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "take_while", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "take_while", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("take_while", javaMethod);
            javaMethod = new RubyArray$i$0$0$sort19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "sort19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "sort19", RubyArray.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("sort", javaMethod);
            javaMethod = new RubyArray$i$0$0$collect19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "collect19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "collect19", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("collect", javaMethod);
            cls.addMethodAtBootTimeOnly("map", javaMethod);
            javaMethod = new RubyArray$i$unshift19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "unshift19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("unshift", javaMethod);
            javaMethod = new RubyArray$i$sample(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "sample", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("sample", javaMethod);
            javaMethod = new RubyArray$i$0$1$shuffle(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "shuffle", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "shuffle", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject[].class }, false);
            cls.addMethodAtBootTimeOnly("shuffle", javaMethod);
            javaMethod = new RubyArray$i$aset19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "aset19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("[]=", javaMethod);
            javaMethod = new RubyArray$i$rotate(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "rotate", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("rotate", javaMethod);
            javaMethod = new RubyArray$i$0$0$drop_while(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "drop_while", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "drop_while", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("drop_while", javaMethod);
            javaMethod = new RubyArray$i$0$0$keep_if(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "keep_if", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "keep_if", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("keep_if", javaMethod);
            javaMethod = new RubyArray$i$1$0$concat19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "concat19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "concat19", RubyArray.class, new Class[] { IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("concat", javaMethod);
            javaMethod = new RubyArray$i$0$0$uniq_bang19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "uniq_bang19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "uniq_bang19", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("uniq!", javaMethod);
            javaMethod = new RubyArray$i$insert19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "insert19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("insert", javaMethod);
            javaMethod = new RubyArray$i$1$0$op_times19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_times19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "op_times19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("*", javaMethod);
            javaMethod = new RubyArray$i$0$0$uniq19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "uniq19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "uniq19", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("uniq", javaMethod);
            javaMethod = new RubyArray$i$0$1$shuffle_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "shuffle_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "shuffle_bang", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject[].class }, false);
            cls.addMethodAtBootTimeOnly("shuffle!", javaMethod);
            javaMethod = new RubyArray$i$aref19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "aref19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("[]", javaMethod);
            cls.addMethodAtBootTimeOnly("slice", javaMethod);
            javaMethod = new RubyArray$i$1$0$take(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "take", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "take", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("take", javaMethod);
            javaMethod = new RubyArray$i$repeated_permutation(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "repeated_permutation", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("repeated_permutation", javaMethod);
            javaMethod = new RubyArray$i$0$0$hash19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "hash19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "hash19", RubyFixnum.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("hash", javaMethod);
            javaMethod = new RubyArray$i$rotate_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "rotate_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("rotate!", javaMethod);
            javaMethod = new RubyArray$i$flatten_bang19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "flatten_bang19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("flatten!", javaMethod);
            javaMethod = new RubyArray$i$1$0$drop(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "drop", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "drop", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("drop", javaMethod);
            javaMethod = new RubyArray$i$0$0$select_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "select_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "select_bang", IRubyObject.class, new Class[] { ThreadContext.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("select!", javaMethod);
            javaMethod = new RubyArray$i$1$0$repeatedCombination(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "repeatedCombination", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "repeatedCombination", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, false);
            cls.addMethodAtBootTimeOnly("repeated_combination", javaMethod);
            javaMethod = new RubyArray$i$1$0$pack19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "pack19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "pack19", RubyString.class, new Class[] { ThreadContext.class, IRubyObject.class }, false);
            cls.addMethodAtBootTimeOnly("pack", javaMethod);
            javaMethod = new RubyArray$i$0$0$push_m19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "push_m19", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyArray.class, "push_m19", RubyArray.class, new Class[] { IRubyObject[].class }, false);
            cls.addMethodAtBootTimeOnly("push", javaMethod);
            javaMethod = new RubyArray$i$join19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "join19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("join", javaMethod);
            javaMethod = new RubyArray$i$flatten19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "flatten19", false, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("flatten", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyArray.product19", "product");
            runtime.addBoundMethod("org.jruby.RubyArray.sort_bang19", "sort!");
            runtime.addBoundMethod("org.jruby.RubyArray.sort_by_bang", "sort_by!");
            runtime.addBoundMethod("org.jruby.RubyArray.take_while", "take_while");
            runtime.addBoundMethod("org.jruby.RubyArray.sort19", "sort");
            runtime.addBoundMethod("org.jruby.RubyArray.collect19", "collect");
            runtime.addBoundMethod("org.jruby.RubyArray.unshift19", "unshift");
            runtime.addBoundMethod("org.jruby.RubyArray.sample", "sample");
            runtime.addBoundMethod("org.jruby.RubyArray.shuffle", "shuffle");
            runtime.addBoundMethod("org.jruby.RubyArray.aset19", "[]=");
            runtime.addBoundMethod("org.jruby.RubyArray.rotate", "rotate");
            runtime.addBoundMethod("org.jruby.RubyArray.drop_while", "drop_while");
            runtime.addBoundMethod("org.jruby.RubyArray.keep_if", "keep_if");
            runtime.addBoundMethod("org.jruby.RubyArray.concat19", "concat");
            runtime.addBoundMethod("org.jruby.RubyArray.uniq_bang19", "uniq!");
            runtime.addBoundMethod("org.jruby.RubyArray.insert19", "insert");
            runtime.addBoundMethod("org.jruby.RubyArray.op_times19", "*");
            runtime.addBoundMethod("org.jruby.RubyArray.uniq19", "uniq");
            runtime.addBoundMethod("org.jruby.RubyArray.shuffle_bang", "shuffle!");
            runtime.addBoundMethod("org.jruby.RubyArray.aref19", "[]");
            runtime.addBoundMethod("org.jruby.RubyArray.take", "take");
            runtime.addBoundMethod("org.jruby.RubyArray.repeated_permutation", "repeated_permutation");
            runtime.addBoundMethod("org.jruby.RubyArray.hash19", "hash");
            runtime.addBoundMethod("org.jruby.RubyArray.rotate_bang", "rotate!");
            runtime.addBoundMethod("org.jruby.RubyArray.flatten_bang19", "flatten!");
            runtime.addBoundMethod("org.jruby.RubyArray.drop", "drop");
            runtime.addBoundMethod("org.jruby.RubyArray.select_bang", "select!");
            runtime.addBoundMethod("org.jruby.RubyArray.repeatedCombination", "repeated_combination");
            runtime.addBoundMethod("org.jruby.RubyArray.pack19", "pack");
            runtime.addBoundMethod("org.jruby.RubyArray.push_m19", "push");
            runtime.addBoundMethod("org.jruby.RubyArray.join19", "join");
            runtime.addBoundMethod("org.jruby.RubyArray.flatten19", "flatten");
        }
    }
}
