// 
// Decompiled by Procyon v0.5.30
// 

package org.jruby.gen;

import org.jruby.compiler.ASTInspector;
import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.Ruby;
import org.jruby.RubyKernel$s$0$0$instance_variables19;
import org.jruby.RubyKernel$s$1$0$method19;
import org.jruby.RubyKernel$s$respond_to_p19;
import org.jruby.RubyKernel$s$0$0$binding19;
import org.jruby.RubyKernel$s$1$0$require19;
import org.jruby.RubyKernel$s$0$1$public_methods19;
import org.jruby.RubyKernel$s$0$0$spawn;
import org.jruby.RubyKernel$s$0$0$global_variables19;
import org.jruby.RubyKernel$s$0$0$local_variables19;
import org.jruby.RubyKernel$s$0$0$trust;
import org.jruby.RubyKernel$s$0$0$lambda;
import org.jruby.RubyKernel$s$0$1$load19;
import org.jruby.RubyKernel$s$1$0$public_method;
import org.jruby.RubyKernel$s$new_integer19;
import org.jruby.RubyKernel$s$1$0$new_float19;
import org.jruby.RubyKernel$s$0$0$public_send;
import org.jruby.RubyKernel$s$0$1$protected_methods19;
import org.jruby.RubyKernel$s$respond_to_missing_p;
import org.jruby.RubyKernel$s$0$0$untrust;
import org.jruby.RubyKernel$s$new_rational;
import org.jruby.RubyKernel$s$rbThrow19;
import org.jruby.RubyKernel$s$rbCatch19;
import org.jruby.RubyKernel$s$0$0$proc_1_9;
import org.jruby.RubyKernel$s$0$0$singleton_class;
import org.jruby.RubyKernel$s$1$0$new_string19;
import org.jruby.RubyKernel$s$send19;
import org.jruby.RubyKernel$s$0$0$untrusted_p;
import org.jruby.RubyKernel$s$0$0$system19;
import org.jruby.RubyKernel$s$0$1$methods19;
import org.jruby.RubyKernel$s$0$1$private_methods19;
import org.jruby.RubyKernel$s$1$0$op_match19;
import org.jruby.RubyKernel$s$0$0$to_enum;
import org.jruby.RubyKernel$s$0$2$open19;
import org.jruby.RubyKernel$s$new_complex;
import org.jruby.RubyKernel$s$0$0$fork19;
import org.jruby.RubyKernel$s$0$3$eval19;
import org.jruby.RubyKernel$s$1$0$op_cmp;
import org.jruby.RubyKernel$s$0$1$singleton_methods19;
import org.jruby.RubyKernel$s$srand19;
import org.jruby.RubyKernel$s$0$1$define_singleton_method;
import org.jruby.RubyKernel$s$1$0$op_not_match;
import org.jruby.RubyKernel$s$rand19;
import org.jruby.RubyKernel$s$1$0$singleton_method_added;
import org.jruby.RubyKernel$s$respond_to_p;
import org.jruby.RubyKernel$s$1$0$require;
import org.jruby.RubyKernel$s$0$1$public_methods;
import org.jruby.RubyKernel$s$gsub_bang;
import org.jruby.RubyKernel$s$0$3$instance_exec;
import org.jruby.RubyKernel$s$0$1$load;
import org.jruby.RubyKernel$s$chomp;
import org.jruby.RubyKernel$s$1$0$new_integer;
import org.jruby.RubyFloat;
import org.jruby.RubyKernel$s$1$0$new_float;
import org.jruby.RubyKernel$s$0$0$chop;
import org.jruby.RubyKernel$s$0$1$protected_methods;
import org.jruby.RubyKernel$s$split;
import org.jruby.RubyKernel$s$0$0$method_missing;
import org.jruby.RubyKernel$s$0$0$to_a;
import org.jruby.RubyKernel$s$sub_bang;
import org.jruby.RubyKernel$s$rbThrow;
import org.jruby.RubyProc;
import org.jruby.RubyKernel$s$0$0$proc;
import org.jruby.RubyKernel$s$1$0$singleton_method_removed;
import org.jruby.RubyKernel$s$1$0$new_string;
import org.jruby.RubyKernel$s$send;
import org.jruby.RubyKernel$s$0$0$chop_bang;
import org.jruby.RubyKernel$s$0$0$system;
import org.jruby.RubyKernel$s$0$1$methods;
import org.jruby.RubyKernel$s$0$1$private_methods;
import org.jruby.RubyKernel$s$1$0$op_match;
import org.jruby.RubyKernel$s$gsub;
import org.jruby.RubyKernel$s$chomp_bang;
import org.jruby.RubyKernel$s$1$0$equal_p;
import org.jruby.RubyKernel$s$1$0$scan;
import org.jruby.RubyKernel$s$1$0$singleton_method_undefined;
import org.jruby.RubyKernel$s$0$2$open;
import org.jruby.RubyKernel$s$0$3$eval;
import org.jruby.RubyKernel$s$0$0$fork;
import org.jruby.RubyKernel$s$0$1$singleton_methods;
import org.jruby.RubyKernel$s$instance_eval;
import org.jruby.RubyKernel$s$srand;
import org.jruby.RubyKernel$s$0$0$id_deprecated;
import org.jruby.RubyKernel$s$1$0$op_equal;
import org.jruby.RubyKernel$s$rand;
import org.jruby.RubyKernel$s$sub;
import org.jruby.CompatVersion;
import org.jruby.RubyKernel$s$0$0$getc;
import org.jruby.RubyKernel$s$0$0$loop;
import org.jruby.RubyKernel$s$1$0$warn;
import org.jruby.RubyKernel$s$1$0$initialize_copy;
import org.jruby.RubyKernel$s$0$0$global_variables;
import org.jruby.RubyKernel$s$0$0$inspect;
import org.jruby.RubyFixnum;
import org.jruby.RubyKernel$s$0$0$hash;
import org.jruby.RubyKernel$s$1$0$instance_of_p;
import org.jruby.RubyKernel$s$0$1$exit;
import org.jruby.RubyKernel$s$1$0$op_eqq;
import org.jruby.RubyKernel$s$0$0$type_deprecated;
import org.jruby.RubyKernel$s$0$1$abort;
import org.jruby.RubyKernel$s$0$0$nil_p;
import org.jruby.RubyKernel$s$0$0$at_exit;
import org.jruby.RubyKernel$s$1$0$instance_variable_get;
import org.jruby.RubyKernel$s$1$0$remove_instance_variable;
import org.jruby.RubyKernel$s$0$0$freeze;
import org.jruby.RubyKernel$s$0$1$trace_var;
import org.jruby.RubyKernel$s$0$0$sprintf;
import org.jruby.RubyKernel$s$0$0$extend;
import org.jruby.RubyKernel$s$0$0$to_s;
import org.jruby.RubyKernel$s$0$1$gets;
import org.jruby.RubyKernel$s$1$0$autoload_p;
import org.jruby.RubyKernel$s$0$1$readlines;
import org.jruby.RubyKernel$s$0$1$display;
import org.jruby.RubyKernel$s$0$0$instance_variables;
import org.jruby.RubyKernel$s$1$0$method;
import org.jruby.RubyKernel$s$1$0$instance_variable_defined_p;
import org.jruby.RubyBinding;
import org.jruby.RubyKernel$s$0$0$binding;
import org.jruby.RubyKernel$s$0$0$puts;
import org.jruby.RubyKernel$s$0$0$dup;
import org.jruby.RubyKernel$s$0$0$taint;
import org.jruby.RubyArray;
import org.jruby.RubyKernel$s$0$0$local_variables;
import org.jruby.RubyKernel$s$0$0$print;
import org.jruby.RubyKernel$s$0$0$tap;
import org.jruby.RubyKernel$s$0$1$trap;
import org.jruby.RubyKernel$s$0$3$select;
import org.jruby.RubyKernel$s$1$0$kind_of_p;
import org.jruby.RubyKernel$s$0$0$tainted_p;
import org.jruby.RubyClass;
import org.jruby.RubyKernel$s$0$0$type;
import org.jruby.RubyKernel$s$0$1$readline;
import org.jruby.RubyKernel$s$1$0$rbCatch;
import org.jruby.RubyKernel$s$0$0$exec;
import org.jruby.RubyKernel$s$0$0$untaint;
import org.jruby.RubyKernel$s$0$1$exit_bang;
import org.jruby.RubyKernel$s$0$0$block_given_p;
import org.jruby.RubyKernel$s$0$1$test;
import org.jruby.RubyKernel$s$0$0$callcc;
import org.jruby.RubyKernel$s$0$0$__method__;
import org.jruby.RubyKernel$s$0$1$sleep;
import org.jruby.RubyKernel$s$2$0$instance_variable_set;
import org.jruby.RubyKernel$s$1$0$backquote;
import org.jruby.RubyKernel$s$1$0$set_trace_func;
import org.jruby.RubyKernel$s$1$0$eql_p;
import org.jruby.RubyKernel$s$1$0$new_array;
import org.jruby.RubyKernel$s$0$3$raise;
import org.jruby.RubyKernel$s$0$0$printf;
import org.jruby.RubyKernel$s$1$0$putc;
import org.jruby.RubyKernel$s$0$0$rbClone;
import org.jruby.RubyKernel$s$0$0$p;
import org.jruby.RubyKernel$s$0$1$untrace_var;
import org.jruby.RubyKernel$s$0$9$syscall;
import org.jruby.RubyBoolean;
import org.jruby.RubyKernel$s$0$0$frozen_p;
import org.jruby.RubyKernel$s$0$0$id;
import org.jruby.RubyKernel$s$2$0$autoload;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.runtime.Block;
import org.jruby.runtime.ThreadContext;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.RubyKernel;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.RubyKernel$s$0$1$caller;
import org.jruby.runtime.Visibility;
import org.jruby.RubyModule;
import org.jruby.anno.TypePopulator;

public class org$jruby$RubyKernel$Populator extends TypePopulator
{
    public void populate(final RubyModule cls, final Class clazz) {
        final RubyClass singletonClass = cls.getSingletonClass();
        final CompatVersion compatVersion = cls.getRuntime().getInstanceConfig().getCompatVersion();
        final Ruby runtime = cls.getRuntime();
        JavaMethod javaMethod = new RubyKernel$s$0$1$caller(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "caller", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "caller", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("caller", javaMethod);
        DynamicMethod moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("caller", moduleMethod);
        javaMethod = new RubyKernel$s$2$0$autoload(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 2, "autoload", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "autoload", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("autoload", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("autoload", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$id(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "id", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "id", IRubyObject.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("object_id", javaMethod);
        cls.addMethodAtBootTimeOnly("__id__", javaMethod);
        javaMethod = new RubyKernel$s$0$0$frozen_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "frozen_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "frozen_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("frozen?", javaMethod);
        javaMethod = new RubyKernel$s$0$9$syscall(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "syscall", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "syscall", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("syscall", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("syscall", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$untrace_var(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "untrace_var", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "untrace_var", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("untrace_var", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("untrace_var", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$p(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("p", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("p", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$rbClone(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "rbClone", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "rbClone", IRubyObject.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("clone", javaMethod);
        javaMethod = new RubyKernel$s$1$0$putc(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "putc", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "putc", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("putc", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("putc", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$printf(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "printf", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "printf", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("printf", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("printf", moduleMethod);
        javaMethod = new RubyKernel$s$0$3$raise(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "raise", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "raise", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("raise", javaMethod);
        cls.addMethodAtBootTimeOnly("fail", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("raise", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("fail", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$new_array(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "new_array", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "new_array", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("Array", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("Array", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$eql_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "eql_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "eql_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("eql?", javaMethod);
        javaMethod = new RubyKernel$s$1$0$set_trace_func(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "set_trace_func", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "set_trace_func", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("set_trace_func", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("set_trace_func", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$backquote(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "backquote", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "backquote", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("`", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("`", moduleMethod);
        javaMethod = new RubyKernel$s$2$0$instance_variable_set(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 2, "instance_variable_set", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "instance_variable_set", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("instance_variable_set", javaMethod);
        javaMethod = new RubyKernel$s$0$1$sleep(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "sleep", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "sleep", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("sleep", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("sleep", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$__method__(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "__method__", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "__method__", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("__method__", javaMethod);
        cls.addMethodAtBootTimeOnly("__callee__", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("__method__", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("__callee__", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$callcc(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "callcc", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "callcc", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("callcc", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("callcc", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$test(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "test", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "test", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("test", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("test", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$block_given_p(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "block_given_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "block_given_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("block_given?", javaMethod);
        cls.addMethodAtBootTimeOnly("iterator?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("block_given?", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("iterator?", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$exit_bang(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "exit_bang", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "exit_bang", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("exit!", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("exit!", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$untaint(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "untaint", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "untaint", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("untaint", javaMethod);
        javaMethod = new RubyKernel$s$0$0$exec(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "exec", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "exec", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("exec", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("exec", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$rbCatch(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "rbCatch", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "rbCatch", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("catch", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("catch", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$readline(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "readline", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "readline", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("readline", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("readline", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$type(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "type", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "type", RubyClass.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("class", javaMethod);
        javaMethod = new RubyKernel$s$0$0$tainted_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "tainted_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "tainted_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("tainted?", javaMethod);
        javaMethod = new RubyKernel$s$1$0$kind_of_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "kind_of_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "kind_of_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("kind_of?", javaMethod);
        cls.addMethodAtBootTimeOnly("is_a?", javaMethod);
        javaMethod = new RubyKernel$s$0$3$select(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "select", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "select", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("select", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("select", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$trap(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "trap", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "trap", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("trap", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("trap", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$tap(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "tap", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "tap", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("tap", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("tap", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$print(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "print", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "print", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("print", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("print", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$local_variables(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "local_variables", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "local_variables", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("local_variables", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("local_variables", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$taint(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "taint", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "taint", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("taint", javaMethod);
        javaMethod = new RubyKernel$s$0$0$dup(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "dup", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "dup", IRubyObject.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("dup", javaMethod);
        javaMethod = new RubyKernel$s$0$0$puts(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "puts", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "puts", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("puts", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("puts", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$binding(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "binding", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "binding", RubyBinding.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("binding", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("binding", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$instance_variable_defined_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "instance_variable_defined_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "instance_variable_defined_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("instance_variable_defined?", javaMethod);
        javaMethod = new RubyKernel$s$1$0$method(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "method", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "method", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("method", javaMethod);
        javaMethod = new RubyKernel$s$0$0$instance_variables(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "instance_variables", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "instance_variables", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("instance_variables", javaMethod);
        javaMethod = new RubyKernel$s$0$1$display(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "display", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "display", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("display", javaMethod);
        javaMethod = new RubyKernel$s$0$1$readlines(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "readlines", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "readlines", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("readlines", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("readlines", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$autoload_p(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "autoload_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "autoload_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("autoload?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("autoload?", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$gets(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "gets", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "gets", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("gets", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("gets", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$to_s(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "to_s", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "to_s", IRubyObject.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("to_s", javaMethod);
        javaMethod = new RubyKernel$s$0$0$extend(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "extend", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "extend", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("extend", javaMethod);
        javaMethod = new RubyKernel$s$0$0$sprintf(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "sprintf", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "sprintf", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("sprintf", javaMethod);
        cls.addMethodAtBootTimeOnly("format", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("sprintf", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("format", moduleMethod);
        javaMethod = new RubyKernel$s$0$1$trace_var(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "trace_var", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "trace_var", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("trace_var", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("trace_var", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$freeze(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "freeze", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "freeze", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("freeze", javaMethod);
        javaMethod = new RubyKernel$s$1$0$remove_instance_variable(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "remove_instance_variable", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "remove_instance_variable", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("remove_instance_variable", javaMethod);
        javaMethod = new RubyKernel$s$1$0$instance_variable_get(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "instance_variable_get", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "instance_variable_get", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("instance_variable_get", javaMethod);
        javaMethod = new RubyKernel$s$0$0$at_exit(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "at_exit", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "at_exit", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("at_exit", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("at_exit", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$nil_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "nil_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "nil_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("nil?", javaMethod);
        javaMethod = new RubyKernel$s$0$1$abort(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "abort", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "abort", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("abort", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("abort", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$type_deprecated(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "type_deprecated", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "type_deprecated", RubyClass.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("type", javaMethod);
        javaMethod = new RubyKernel$s$1$0$op_eqq(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_eqq", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "op_eqq", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("===", javaMethod);
        javaMethod = new RubyKernel$s$0$1$exit(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "exit", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "exit", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject[].class }, true);
        cls.addMethodAtBootTimeOnly("exit", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("exit", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$instance_of_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "instance_of_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "instance_of_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("instance_of?", javaMethod);
        javaMethod = new RubyKernel$s$0$0$hash(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "hash", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "hash", RubyFixnum.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("hash", javaMethod);
        javaMethod = new RubyKernel$s$0$0$inspect(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "inspect", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "inspect", IRubyObject.class, new Class[] { IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("inspect", javaMethod);
        javaMethod = new RubyKernel$s$0$0$global_variables(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "global_variables", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "global_variables", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("global_variables", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("global_variables", moduleMethod);
        javaMethod = new RubyKernel$s$1$0$initialize_copy(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "initialize_copy", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "initialize_copy", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("initialize_copy", javaMethod);
        javaMethod = new RubyKernel$s$1$0$warn(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 1, "warn", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "warn", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("warn", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("warn", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$loop(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "loop", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "loop", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
        cls.addMethodAtBootTimeOnly("loop", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("loop", moduleMethod);
        javaMethod = new RubyKernel$s$0$0$getc(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, 0, "getc", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyKernel.class, "getc", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("getc", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("getc", moduleMethod);
        runtime.addBoundMethod("org.jruby.RubyKernel.autoload", "autoload");
        runtime.addBoundMethod("org.jruby.RubyKernel.id", "object_id");
        runtime.addBoundMethod("org.jruby.RubyKernel.frozen_p", "frozen?");
        runtime.addBoundMethod("org.jruby.RubyKernel.syscall", "syscall");
        runtime.addBoundMethod("org.jruby.RubyKernel.untrace_var", "untrace_var");
        runtime.addBoundMethod("org.jruby.RubyKernel.p", "p");
        runtime.addBoundMethod("org.jruby.RubyKernel.rbClone", "clone");
        runtime.addBoundMethod("org.jruby.RubyKernel.putc", "putc");
        runtime.addBoundMethod("org.jruby.RubyKernel.printf", "printf");
        runtime.addBoundMethod("org.jruby.RubyKernel.new_array", "Array");
        runtime.addBoundMethod("org.jruby.RubyKernel.eql_p", "eql?");
        runtime.addBoundMethod("org.jruby.RubyKernel.set_trace_func", "set_trace_func");
        runtime.addBoundMethod("org.jruby.RubyKernel.backquote", "`");
        runtime.addBoundMethod("org.jruby.RubyKernel.instance_variable_set", "instance_variable_set");
        runtime.addBoundMethod("org.jruby.RubyKernel.sleep", "sleep");
        runtime.addBoundMethod("org.jruby.RubyKernel.callcc", "callcc");
        runtime.addBoundMethod("org.jruby.RubyKernel.test", "test");
        runtime.addBoundMethod("org.jruby.RubyKernel.block_given_p", "block_given?");
        runtime.addBoundMethod("org.jruby.RubyKernel.exit_bang", "exit!");
        runtime.addBoundMethod("org.jruby.RubyKernel.untaint", "untaint");
        runtime.addBoundMethod("org.jruby.RubyKernel.exec", "exec");
        runtime.addBoundMethod("org.jruby.RubyKernel.rbCatch", "catch");
        runtime.addBoundMethod("org.jruby.RubyKernel.readline", "readline");
        runtime.addBoundMethod("org.jruby.RubyKernel.type", "class");
        runtime.addBoundMethod("org.jruby.RubyKernel.tainted_p", "tainted?");
        runtime.addBoundMethod("org.jruby.RubyKernel.kind_of_p", "kind_of?");
        runtime.addBoundMethod("org.jruby.RubyKernel.select", "select");
        runtime.addBoundMethod("org.jruby.RubyKernel.trap", "trap");
        runtime.addBoundMethod("org.jruby.RubyKernel.tap", "tap");
        runtime.addBoundMethod("org.jruby.RubyKernel.print", "print");
        runtime.addBoundMethod("org.jruby.RubyKernel.local_variables", "local_variables");
        runtime.addBoundMethod("org.jruby.RubyKernel.taint", "taint");
        runtime.addBoundMethod("org.jruby.RubyKernel.dup", "dup");
        runtime.addBoundMethod("org.jruby.RubyKernel.puts", "puts");
        runtime.addBoundMethod("org.jruby.RubyKernel.binding", "binding");
        runtime.addBoundMethod("org.jruby.RubyKernel.instance_variable_defined_p", "instance_variable_defined?");
        runtime.addBoundMethod("org.jruby.RubyKernel.method", "method");
        runtime.addBoundMethod("org.jruby.RubyKernel.instance_variables", "instance_variables");
        runtime.addBoundMethod("org.jruby.RubyKernel.display", "display");
        runtime.addBoundMethod("org.jruby.RubyKernel.readlines", "readlines");
        runtime.addBoundMethod("org.jruby.RubyKernel.autoload_p", "autoload?");
        runtime.addBoundMethod("org.jruby.RubyKernel.gets", "gets");
        runtime.addBoundMethod("org.jruby.RubyKernel.to_s", "to_s");
        runtime.addBoundMethod("org.jruby.RubyKernel.extend", "extend");
        runtime.addBoundMethod("org.jruby.RubyKernel.sprintf", "sprintf");
        runtime.addBoundMethod("org.jruby.RubyKernel.trace_var", "trace_var");
        runtime.addBoundMethod("org.jruby.RubyKernel.freeze", "freeze");
        runtime.addBoundMethod("org.jruby.RubyKernel.remove_instance_variable", "remove_instance_variable");
        runtime.addBoundMethod("org.jruby.RubyKernel.instance_variable_get", "instance_variable_get");
        runtime.addBoundMethod("org.jruby.RubyKernel.at_exit", "at_exit");
        runtime.addBoundMethod("org.jruby.RubyKernel.nil_p", "nil?");
        runtime.addBoundMethod("org.jruby.RubyKernel.abort", "abort");
        runtime.addBoundMethod("org.jruby.RubyKernel.type_deprecated", "type");
        runtime.addBoundMethod("org.jruby.RubyKernel.op_eqq", "===");
        runtime.addBoundMethod("org.jruby.RubyKernel.exit", "exit");
        runtime.addBoundMethod("org.jruby.RubyKernel.instance_of_p", "instance_of?");
        runtime.addBoundMethod("org.jruby.RubyKernel.hash", "hash");
        runtime.addBoundMethod("org.jruby.RubyKernel.inspect", "inspect");
        runtime.addBoundMethod("org.jruby.RubyKernel.global_variables", "global_variables");
        runtime.addBoundMethod("org.jruby.RubyKernel.initialize_copy", "initialize_copy");
        runtime.addBoundMethod("org.jruby.RubyKernel.warn", "warn");
        runtime.addBoundMethod("org.jruby.RubyKernel.loop", "loop");
        runtime.addBoundMethod("org.jruby.RubyKernel.getc", "getc");
        if (compatVersion == CompatVersion.RUBY1_8 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyKernel$s$sub(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "sub", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("sub", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sub", moduleMethod);
            javaMethod = new RubyKernel$s$rand(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "rand", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("rand", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("rand", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$op_equal(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_equal", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "op_equal", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("==", javaMethod);
            javaMethod = new RubyKernel$s$0$0$id_deprecated(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "id_deprecated", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "id_deprecated", IRubyObject.class, new Class[] { IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("id", javaMethod);
            javaMethod = new RubyKernel$s$srand(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "srand", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("srand", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("srand", moduleMethod);
            javaMethod = new RubyKernel$s$instance_eval(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "instance_eval", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("instance_eval", javaMethod);
            javaMethod = new RubyKernel$s$0$1$singleton_methods(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "singleton_methods", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "singleton_methods", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("singleton_methods", javaMethod);
            javaMethod = new RubyKernel$s$0$0$fork(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "fork", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "fork", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("fork", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("fork", moduleMethod);
            javaMethod = new RubyKernel$s$0$3$eval(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "eval", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "eval", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("eval", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("eval", moduleMethod);
            javaMethod = new RubyKernel$s$0$2$open(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "open", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "open", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("open", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("open", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$singleton_method_undefined(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "singleton_method_undefined", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "singleton_method_undefined", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("singleton_method_undefined", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("singleton_method_undefined", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$scan(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "scan", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "scan", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("scan", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("scan", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$equal_p(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "equal_p", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "equal_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("equal?", javaMethod);
            javaMethod = new RubyKernel$s$chomp_bang(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "chomp_bang", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("chomp!", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("chomp!", moduleMethod);
            javaMethod = new RubyKernel$s$gsub(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "gsub", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("gsub", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("gsub", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$op_match(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_match", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "op_match", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("=~", javaMethod);
            javaMethod = new RubyKernel$s$0$1$private_methods(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "private_methods", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "private_methods", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("private_methods", javaMethod);
            javaMethod = new RubyKernel$s$0$1$methods(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "methods", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "methods", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("methods", javaMethod);
            javaMethod = new RubyKernel$s$0$0$system(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "system", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "system", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("system", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("system", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$chop_bang(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "chop_bang", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "chop_bang", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("chop!", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("chop!", moduleMethod);
            javaMethod = new RubyKernel$s$send(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "send", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("send", javaMethod);
            cls.addMethodAtBootTimeOnly("__send__", javaMethod);
            javaMethod = new RubyKernel$s$1$0$new_string(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "new_string", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "new_string", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("String", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("String", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$singleton_method_removed(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "singleton_method_removed", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "singleton_method_removed", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("singleton_method_removed", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("singleton_method_removed", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$proc(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "proc", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "proc", RubyProc.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("proc", javaMethod);
            cls.addMethodAtBootTimeOnly("lambda", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("proc", moduleMethod);
            singletonClass.addMethodAtBootTimeOnly("lambda", moduleMethod);
            javaMethod = new RubyKernel$s$rbThrow(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "rbThrow", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("throw", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("throw", moduleMethod);
            javaMethod = new RubyKernel$s$sub_bang(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "sub_bang", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("sub!", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sub!", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$to_a(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "to_a", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "to_a", RubyArray.class, new Class[] { IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("to_a", javaMethod);
            javaMethod = new RubyKernel$s$0$0$method_missing(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "method_missing", true, CallConfiguration.FrameFullScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "method_missing", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("method_missing", javaMethod);
            javaMethod = new RubyKernel$s$split(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "split", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("split", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("split", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$protected_methods(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "protected_methods", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "protected_methods", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("protected_methods", javaMethod);
            javaMethod = new RubyKernel$s$0$0$chop(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "chop", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "chop", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("chop", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("chop", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$new_float(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "new_float", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "new_float", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("Float", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("Float", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$new_integer(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "new_integer", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "new_integer", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("Integer", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("Integer", moduleMethod);
            javaMethod = new RubyKernel$s$chomp(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "chomp", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("chomp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("chomp", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$load(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "load", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "load", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("load", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("load", moduleMethod);
            javaMethod = new RubyKernel$s$0$3$instance_exec(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "instance_exec", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "instance_exec", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("instance_exec", javaMethod);
            javaMethod = new RubyKernel$s$gsub_bang(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "gsub_bang", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("gsub!", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("gsub!", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$public_methods(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "public_methods", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "public_methods", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("public_methods", javaMethod);
            javaMethod = new RubyKernel$s$1$0$require(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "require", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "require", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("require", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("require", moduleMethod);
            javaMethod = new RubyKernel$s$respond_to_p(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "respond_to_p", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("respond_to?", javaMethod);
            javaMethod = new RubyKernel$s$1$0$singleton_method_added(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "singleton_method_added", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "singleton_method_added", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("singleton_method_added", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("singleton_method_added", moduleMethod);
            runtime.addBoundMethod("org.jruby.RubyKernel.sub", "sub");
            runtime.addBoundMethod("org.jruby.RubyKernel.rand", "rand");
            runtime.addBoundMethod("org.jruby.RubyKernel.op_equal", "==");
            runtime.addBoundMethod("org.jruby.RubyKernel.id_deprecated", "id");
            runtime.addBoundMethod("org.jruby.RubyKernel.srand", "srand");
            runtime.addBoundMethod("org.jruby.RubyKernel.instance_eval", "instance_eval");
            runtime.addBoundMethod("org.jruby.RubyKernel.singleton_methods", "singleton_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.fork", "fork");
            runtime.addBoundMethod("org.jruby.RubyKernel.eval", "eval");
            runtime.addBoundMethod("org.jruby.RubyKernel.open", "open");
            runtime.addBoundMethod("org.jruby.RubyKernel.singleton_method_undefined", "singleton_method_undefined");
            runtime.addBoundMethod("org.jruby.RubyKernel.scan", "scan");
            runtime.addBoundMethod("org.jruby.RubyKernel.equal_p", "equal?");
            runtime.addBoundMethod("org.jruby.RubyKernel.chomp_bang", "chomp!");
            runtime.addBoundMethod("org.jruby.RubyKernel.gsub", "gsub");
            runtime.addBoundMethod("org.jruby.RubyKernel.op_match", "=~");
            runtime.addBoundMethod("org.jruby.RubyKernel.private_methods", "private_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.methods", "methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.system", "system");
            runtime.addBoundMethod("org.jruby.RubyKernel.chop_bang", "chop!");
            runtime.addBoundMethod("org.jruby.RubyKernel.send", "send");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_string", "String");
            runtime.addBoundMethod("org.jruby.RubyKernel.singleton_method_removed", "singleton_method_removed");
            runtime.addBoundMethod("org.jruby.RubyKernel.proc", "proc");
            runtime.addBoundMethod("org.jruby.RubyKernel.rbThrow", "throw");
            runtime.addBoundMethod("org.jruby.RubyKernel.sub_bang", "sub!");
            runtime.addBoundMethod("org.jruby.RubyKernel.to_a", "to_a");
            runtime.addBoundMethod("org.jruby.RubyKernel.method_missing", "method_missing");
            runtime.addBoundMethod("org.jruby.RubyKernel.split", "split");
            runtime.addBoundMethod("org.jruby.RubyKernel.protected_methods", "protected_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.chop", "chop");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_float", "Float");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_integer", "Integer");
            runtime.addBoundMethod("org.jruby.RubyKernel.chomp", "chomp");
            runtime.addBoundMethod("org.jruby.RubyKernel.load", "load");
            runtime.addBoundMethod("org.jruby.RubyKernel.instance_exec", "instance_exec");
            runtime.addBoundMethod("org.jruby.RubyKernel.gsub_bang", "gsub!");
            runtime.addBoundMethod("org.jruby.RubyKernel.public_methods", "public_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.require", "require");
            runtime.addBoundMethod("org.jruby.RubyKernel.respond_to_p", "respond_to?");
            runtime.addBoundMethod("org.jruby.RubyKernel.singleton_method_added", "singleton_method_added");
        }
        if (compatVersion == CompatVersion.RUBY1_9 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyKernel$s$rand19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "rand19", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("rand", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("rand", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$op_not_match(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_not_match", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "op_not_match", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("!~", javaMethod);
            javaMethod = new RubyKernel$s$0$1$define_singleton_method(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "define_singleton_method", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "define_singleton_method", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("define_singleton_method", javaMethod);
            javaMethod = new RubyKernel$s$srand19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "srand19", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("srand", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("srand", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$singleton_methods19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "singleton_methods19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "singleton_methods19", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("singleton_methods", javaMethod);
            javaMethod = new RubyKernel$s$1$0$op_cmp(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_cmp", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "op_cmp", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("<=>", javaMethod);
            javaMethod = new RubyKernel$s$0$3$eval19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "eval19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "eval19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("eval", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("eval", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$fork19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "fork19", true, CallConfiguration.FrameNoneScopeNone, true);
            javaMethod.setNativeCall(RubyKernel.class, "fork19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("fork", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("fork", moduleMethod);
            javaMethod = new RubyKernel$s$new_complex(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "new_complex", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("Complex", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("Complex", moduleMethod);
            javaMethod = new RubyKernel$s$0$2$open19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "open19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "open19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("open", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("open", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$to_enum(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "to_enum", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "to_enum", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("to_enum", javaMethod);
            cls.addMethodAtBootTimeOnly("enum_for", javaMethod);
            javaMethod = new RubyKernel$s$1$0$op_match19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "op_match19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "op_match19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("=~", javaMethod);
            javaMethod = new RubyKernel$s$0$1$private_methods19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "private_methods19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "private_methods19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("private_methods", javaMethod);
            javaMethod = new RubyKernel$s$0$1$methods19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "methods19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "methods19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("methods", javaMethod);
            javaMethod = new RubyKernel$s$0$0$system19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "system19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "system19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("system", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("system", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$untrusted_p(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "untrusted_p", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "untrusted_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("untrusted?", javaMethod);
            javaMethod = new RubyKernel$s$send19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "send19", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("send", javaMethod);
            javaMethod = new RubyKernel$s$1$0$new_string19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "new_string19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "new_string19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("String", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("String", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$singleton_class(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "singleton_class", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "singleton_class", IRubyObject.class, new Class[] { IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("singleton_class", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("singleton_class", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$proc_1_9(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "proc_1_9", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "proc_1_9", RubyProc.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("proc", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("proc", moduleMethod);
            javaMethod = new RubyKernel$s$rbCatch19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "rbCatch19", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("catch", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("catch", moduleMethod);
            javaMethod = new RubyKernel$s$rbThrow19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "rbThrow19", true, CallConfiguration.FrameFullScopeNone, false);
            cls.addMethodAtBootTimeOnly("throw", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("throw", moduleMethod);
            javaMethod = new RubyKernel$s$new_rational(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "new_rational", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("Rational", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("Rational", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$untrust(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "untrust", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "untrust", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("untrust", javaMethod);
            javaMethod = new RubyKernel$s$respond_to_missing_p(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "respond_to_missing_p", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("respond_to_missing?", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("respond_to_missing?", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$protected_methods19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "protected_methods19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "protected_methods19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("protected_methods", javaMethod);
            javaMethod = new RubyKernel$s$0$0$public_send(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "public_send", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "public_send", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("public_send", javaMethod);
            javaMethod = new RubyKernel$s$1$0$new_float19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "new_float19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "new_float19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("Float", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("Float", moduleMethod);
            javaMethod = new RubyKernel$s$new_integer19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "new_integer19", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("Integer", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("Integer", moduleMethod);
            javaMethod = new RubyKernel$s$1$0$public_method(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "public_method", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "public_method", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("public_method", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("public_method", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$load19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "load19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "load19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("load", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("load", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$lambda(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "lambda", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "lambda", RubyProc.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("lambda", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("lambda", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$trust(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "trust", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "trust", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("trust", javaMethod);
            javaMethod = new RubyKernel$s$0$0$local_variables19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "local_variables19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "local_variables19", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("local_variables", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("local_variables", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$global_variables19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "global_variables19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "global_variables19", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("global_variables", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("global_variables", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$spawn(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "spawn", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "spawn", RubyFixnum.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("spawn", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("spawn", moduleMethod);
            javaMethod = new RubyKernel$s$0$1$public_methods19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "public_methods19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "public_methods19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("public_methods", javaMethod);
            javaMethod = new RubyKernel$s$1$0$require19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "require19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "require19", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("require", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("require", moduleMethod);
            javaMethod = new RubyKernel$s$0$0$binding19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 0, "binding19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "binding19", RubyBinding.class, new Class[] { ThreadContext.class, IRubyObject.class, Block.class }, true);
            cls.addMethodAtBootTimeOnly("binding", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("binding", moduleMethod);
            javaMethod = new RubyKernel$s$respond_to_p19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, -1, "respond_to_p19", true, CallConfiguration.FrameNoneScopeNone, false);
            cls.addMethodAtBootTimeOnly("respond_to?", javaMethod);
            javaMethod = new RubyKernel$s$1$0$method19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "method19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "method19", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("method", javaMethod);
            javaMethod = new RubyKernel$s$0$0$instance_variables19(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "instance_variables19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyKernel.class, "instance_variables19", RubyArray.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("instance_variables", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyKernel.rand19", "rand");
            runtime.addBoundMethod("org.jruby.RubyKernel.op_not_match", "!~");
            runtime.addBoundMethod("org.jruby.RubyKernel.define_singleton_method", "define_singleton_method");
            runtime.addBoundMethod("org.jruby.RubyKernel.srand19", "srand");
            runtime.addBoundMethod("org.jruby.RubyKernel.singleton_methods19", "singleton_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.op_cmp", "<=>");
            runtime.addBoundMethod("org.jruby.RubyKernel.eval19", "eval");
            runtime.addBoundMethod("org.jruby.RubyKernel.fork19", "fork");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_complex", "Complex");
            runtime.addBoundMethod("org.jruby.RubyKernel.open19", "open");
            runtime.addBoundMethod("org.jruby.RubyKernel.to_enum", "to_enum");
            runtime.addBoundMethod("org.jruby.RubyKernel.op_match19", "=~");
            runtime.addBoundMethod("org.jruby.RubyKernel.private_methods19", "private_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.methods19", "methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.system19", "system");
            runtime.addBoundMethod("org.jruby.RubyKernel.untrusted_p", "untrusted?");
            runtime.addBoundMethod("org.jruby.RubyKernel.send19", "send");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_string19", "String");
            runtime.addBoundMethod("org.jruby.RubyKernel.singleton_class", "singleton_class");
            runtime.addBoundMethod("org.jruby.RubyKernel.proc_1_9", "proc");
            runtime.addBoundMethod("org.jruby.RubyKernel.rbCatch19", "catch");
            runtime.addBoundMethod("org.jruby.RubyKernel.rbThrow19", "throw");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_rational", "Rational");
            runtime.addBoundMethod("org.jruby.RubyKernel.untrust", "untrust");
            runtime.addBoundMethod("org.jruby.RubyKernel.respond_to_missing_p", "respond_to_missing?");
            runtime.addBoundMethod("org.jruby.RubyKernel.protected_methods19", "protected_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.public_send", "public_send");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_float19", "Float");
            runtime.addBoundMethod("org.jruby.RubyKernel.new_integer19", "Integer");
            runtime.addBoundMethod("org.jruby.RubyKernel.public_method", "public_method");
            runtime.addBoundMethod("org.jruby.RubyKernel.load19", "load");
            runtime.addBoundMethod("org.jruby.RubyKernel.lambda", "lambda");
            runtime.addBoundMethod("org.jruby.RubyKernel.trust", "trust");
            runtime.addBoundMethod("org.jruby.RubyKernel.local_variables19", "local_variables");
            runtime.addBoundMethod("org.jruby.RubyKernel.global_variables19", "global_variables");
            runtime.addBoundMethod("org.jruby.RubyKernel.spawn", "spawn");
            runtime.addBoundMethod("org.jruby.RubyKernel.public_methods19", "public_methods");
            runtime.addBoundMethod("org.jruby.RubyKernel.require19", "require");
            runtime.addBoundMethod("org.jruby.RubyKernel.binding19", "binding");
            runtime.addBoundMethod("org.jruby.RubyKernel.respond_to_p19", "respond_to?");
            runtime.addBoundMethod("org.jruby.RubyKernel.method19", "method");
            runtime.addBoundMethod("org.jruby.RubyKernel.instance_variables19", "instance_variables");
        }
    }
    
    static {
        ASTInspector.addFrameAwareMethods("throw", "__callee__", "__method__");
        ASTInspector.addScopeAwareMethods("sub!", "chomp!", "sub", "gsub!", "chop!");
    }
}
