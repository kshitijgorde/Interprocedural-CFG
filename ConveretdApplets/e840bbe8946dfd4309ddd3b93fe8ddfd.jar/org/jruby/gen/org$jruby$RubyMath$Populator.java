// 
// Decompiled by Procyon v0.5.30
// 

package org.jruby.gen;

import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.Ruby;
import org.jruby.RubyClass;
import org.jruby.RubyMath$s$1$0$sinh19;
import org.jruby.RubyMath$s$1$0$log10_19;
import org.jruby.RubyMath$s$1$0$lgamma;
import org.jruby.RubyMath$s$1$0$cos19;
import org.jruby.RubyMath$s$2$0$hypot19;
import org.jruby.RubyMath$s$1$0$cbrt;
import org.jruby.RubyMath$s$1$0$exp19;
import org.jruby.RubyMath$s$1$0$erf19;
import org.jruby.RubyMath$s$2$0$atan219;
import org.jruby.RubyMath$s$1$0$atanh_19;
import org.jruby.RubyMath$s$1$0$tan19;
import org.jruby.RubyMath$s$1$0$sin19;
import org.jruby.RubyMath$s$1$0$acos19;
import org.jruby.RubyMath$s$1$0$log2_19;
import org.jruby.RubyMath$s$1$0$acosh19;
import org.jruby.RubyMath$s$1$0$asin19;
import org.jruby.RubyMath$s$1$0$frexp19;
import org.jruby.RubyMath$s$1$0$erfc19;
import org.jruby.RubyMath$s$1$0$atan19;
import org.jruby.RubyMath$s$2$0$ldexp19;
import org.jruby.RubyMath$s$1$0$sqrt19;
import org.jruby.RubyMath$s$1$0$tanh19;
import org.jruby.RubyMath$s$1$0$cosh19;
import org.jruby.RubyMath$s$1$0$gamma;
import org.jruby.RubyMath$s$0$1$log_19;
import org.jruby.RubyMath$s$1$0$asinh19;
import org.jruby.RubyMath$s$1$0$acosh;
import org.jruby.RubyMath$s$1$0$log2;
import org.jruby.RubyMath$s$1$0$sinh;
import org.jruby.RubyMath$s$1$0$asin;
import org.jruby.RubyMath$s$1$0$log10;
import org.jruby.RubyArray;
import org.jruby.RubyMath$s$1$0$frexp;
import org.jruby.RubyMath$s$1$0$cos;
import org.jruby.RubyMath$s$1$0$erfc;
import org.jruby.RubyMath$s$1$0$atan;
import org.jruby.RubyMath$s$1$0$exp;
import org.jruby.RubyMath$s$2$0$hypot;
import org.jruby.RubyMath$s$2$0$ldexp;
import org.jruby.RubyMath$s$1$0$erf;
import org.jruby.RubyMath$s$2$0$atan2;
import org.jruby.RubyMath$s$1$0$sqrt;
import org.jruby.RubyMath$s$1$0$tanh;
import org.jruby.RubyMath$s$1$0$atanh;
import org.jruby.RubyMath$s$1$0$cosh;
import org.jruby.RubyMath$s$1$0$tan;
import org.jruby.RubyMath$s$1$0$sin;
import org.jruby.RubyMath$s$1$0$asinh;
import org.jruby.RubyMath$s$1$0$acos;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.RubyFloat;
import org.jruby.RubyMath;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.RubyMath$s$1$0$log;
import org.jruby.runtime.Visibility;
import org.jruby.CompatVersion;
import org.jruby.RubyModule;
import org.jruby.anno.TypePopulator;

public class org$jruby$RubyMath$Populator extends TypePopulator
{
    public void populate(final RubyModule cls, final Class clazz) {
        final RubyClass singletonClass = cls.getSingletonClass();
        final CompatVersion compatVersion = cls.getRuntime().getInstanceConfig().getCompatVersion();
        final Ruby runtime = cls.getRuntime();
        if (compatVersion == CompatVersion.RUBY1_8 || compatVersion == CompatVersion.BOTH) {
            JavaMethod javaMethod = new RubyMath$s$1$0$log(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "log", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "log", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("log", javaMethod);
            DynamicMethod moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("log", moduleMethod);
            javaMethod = new RubyMath$s$1$0$acos(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "acos", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "acos", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("acos", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("acos", moduleMethod);
            javaMethod = new RubyMath$s$1$0$asinh(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "asinh", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "asinh", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("asinh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("asinh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$sin(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "sin", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "sin", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("sin", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sin", moduleMethod);
            javaMethod = new RubyMath$s$1$0$tan(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "tan", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "tan", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("tan", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("tan", moduleMethod);
            javaMethod = new RubyMath$s$1$0$cosh(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "cosh", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "cosh", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("cosh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("cosh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$atanh(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "atanh", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "atanh", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("atanh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("atanh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$tanh(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "tanh", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "tanh", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("tanh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("tanh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$sqrt(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "sqrt", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "sqrt", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("sqrt", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sqrt", moduleMethod);
            javaMethod = new RubyMath$s$2$0$atan2(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 2, "atan2", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "atan2", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("atan2", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("atan2", moduleMethod);
            javaMethod = new RubyMath$s$1$0$erf(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "erf", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "erf", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("erf", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("erf", moduleMethod);
            javaMethod = new RubyMath$s$2$0$ldexp(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 2, "ldexp", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "ldexp", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("ldexp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("ldexp", moduleMethod);
            javaMethod = new RubyMath$s$2$0$hypot(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 2, "hypot", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "hypot", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("hypot", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("hypot", moduleMethod);
            javaMethod = new RubyMath$s$1$0$exp(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "exp", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "exp", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("exp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("exp", moduleMethod);
            javaMethod = new RubyMath$s$1$0$atan(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "atan", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "atan", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("atan", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("atan", moduleMethod);
            javaMethod = new RubyMath$s$1$0$erfc(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "erfc", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "erfc", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("erfc", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("erfc", moduleMethod);
            javaMethod = new RubyMath$s$1$0$cos(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "cos", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "cos", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("cos", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("cos", moduleMethod);
            javaMethod = new RubyMath$s$1$0$frexp(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "frexp", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "frexp", RubyArray.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("frexp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("frexp", moduleMethod);
            javaMethod = new RubyMath$s$1$0$log10(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "log10", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "log10", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("log10", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("log10", moduleMethod);
            javaMethod = new RubyMath$s$1$0$asin(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "asin", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "asin", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("asin", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("asin", moduleMethod);
            javaMethod = new RubyMath$s$1$0$sinh(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "sinh", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "sinh", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("sinh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sinh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$log2(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "log2", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "log2", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("log2", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("log2", moduleMethod);
            javaMethod = new RubyMath$s$1$0$acosh(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "acosh", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "acosh", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("acosh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("acosh", moduleMethod);
            runtime.addBoundMethod("org.jruby.RubyMath.log", "log");
            runtime.addBoundMethod("org.jruby.RubyMath.acos", "acos");
            runtime.addBoundMethod("org.jruby.RubyMath.asinh", "asinh");
            runtime.addBoundMethod("org.jruby.RubyMath.sin", "sin");
            runtime.addBoundMethod("org.jruby.RubyMath.tan", "tan");
            runtime.addBoundMethod("org.jruby.RubyMath.cosh", "cosh");
            runtime.addBoundMethod("org.jruby.RubyMath.atanh", "atanh");
            runtime.addBoundMethod("org.jruby.RubyMath.tanh", "tanh");
            runtime.addBoundMethod("org.jruby.RubyMath.sqrt", "sqrt");
            runtime.addBoundMethod("org.jruby.RubyMath.atan2", "atan2");
            runtime.addBoundMethod("org.jruby.RubyMath.erf", "erf");
            runtime.addBoundMethod("org.jruby.RubyMath.ldexp", "ldexp");
            runtime.addBoundMethod("org.jruby.RubyMath.hypot", "hypot");
            runtime.addBoundMethod("org.jruby.RubyMath.exp", "exp");
            runtime.addBoundMethod("org.jruby.RubyMath.atan", "atan");
            runtime.addBoundMethod("org.jruby.RubyMath.erfc", "erfc");
            runtime.addBoundMethod("org.jruby.RubyMath.cos", "cos");
            runtime.addBoundMethod("org.jruby.RubyMath.frexp", "frexp");
            runtime.addBoundMethod("org.jruby.RubyMath.log10", "log10");
            runtime.addBoundMethod("org.jruby.RubyMath.asin", "asin");
            runtime.addBoundMethod("org.jruby.RubyMath.sinh", "sinh");
            runtime.addBoundMethod("org.jruby.RubyMath.log2", "log2");
            runtime.addBoundMethod("org.jruby.RubyMath.acosh", "acosh");
        }
        if (compatVersion == CompatVersion.RUBY1_9 || compatVersion == CompatVersion.BOTH) {
            JavaMethod javaMethod = new RubyMath$s$1$0$asinh19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "asinh19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "asinh19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("asinh", javaMethod);
            DynamicMethod moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("asinh", moduleMethod);
            javaMethod = new RubyMath$s$0$1$log_19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, -1, "log_19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "log_19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject[].class }, true);
            cls.addMethodAtBootTimeOnly("log", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("log", moduleMethod);
            javaMethod = new RubyMath$s$1$0$gamma(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "gamma", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "gamma", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("gamma", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("gamma", moduleMethod);
            javaMethod = new RubyMath$s$1$0$cosh19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "cosh19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "cosh19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("cosh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("cosh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$tanh19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "tanh19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "tanh19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("tanh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("tanh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$sqrt19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "sqrt19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "sqrt19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("sqrt", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sqrt", moduleMethod);
            javaMethod = new RubyMath$s$2$0$ldexp19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 2, "ldexp19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "ldexp19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("ldexp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("ldexp", moduleMethod);
            javaMethod = new RubyMath$s$1$0$atan19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "atan19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "atan19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("atan", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("atan", moduleMethod);
            javaMethod = new RubyMath$s$1$0$erfc19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "erfc19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "erfc19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("erfc", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("erfc", moduleMethod);
            javaMethod = new RubyMath$s$1$0$frexp19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "frexp19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "frexp19", RubyArray.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("frexp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("frexp", moduleMethod);
            javaMethod = new RubyMath$s$1$0$asin19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "asin19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "asin19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("asin", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("asin", moduleMethod);
            javaMethod = new RubyMath$s$1$0$acosh19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "acosh19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "acosh19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("acosh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("acosh", moduleMethod);
            javaMethod = new RubyMath$s$1$0$log2_19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "log2_19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "log2_19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("log2", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("log2", moduleMethod);
            javaMethod = new RubyMath$s$1$0$acos19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "acos19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "acos19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("acos", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("acos", moduleMethod);
            javaMethod = new RubyMath$s$1$0$sin19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "sin19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "sin19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("sin", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sin", moduleMethod);
            javaMethod = new RubyMath$s$1$0$tan19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "tan19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "tan19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("tan", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("tan", moduleMethod);
            javaMethod = new RubyMath$s$1$0$atanh_19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "atanh_19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "atanh_19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("atanh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("atanh", moduleMethod);
            javaMethod = new RubyMath$s$2$0$atan219(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 2, "atan219", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "atan219", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("atan2", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("atan2", moduleMethod);
            javaMethod = new RubyMath$s$1$0$erf19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "erf19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "erf19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("erf", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("erf", moduleMethod);
            javaMethod = new RubyMath$s$1$0$exp19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "exp19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "exp19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("exp", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("exp", moduleMethod);
            javaMethod = new RubyMath$s$1$0$cbrt(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "cbrt", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "cbrt", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("cbrt", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("cbrt", moduleMethod);
            javaMethod = new RubyMath$s$2$0$hypot19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 2, "hypot19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "hypot19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("hypot", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("hypot", moduleMethod);
            javaMethod = new RubyMath$s$1$0$cos19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "cos19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "cos19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("cos", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("cos", moduleMethod);
            javaMethod = new RubyMath$s$1$0$lgamma(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "lgamma", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "lgamma", RubyArray.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("lgamma", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("lgamma", moduleMethod);
            javaMethod = new RubyMath$s$1$0$log10_19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "log10_19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "log10_19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("log10", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("log10", moduleMethod);
            javaMethod = new RubyMath$s$1$0$sinh19(cls, Visibility.PRIVATE);
            TypePopulator.populateMethod(javaMethod, 1, "sinh19", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyMath.class, "sinh19", RubyFloat.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("sinh", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("sinh", moduleMethod);
            runtime.addBoundMethod("org.jruby.RubyMath.asinh19", "asinh");
            runtime.addBoundMethod("org.jruby.RubyMath.log_19", "log");
            runtime.addBoundMethod("org.jruby.RubyMath.gamma", "gamma");
            runtime.addBoundMethod("org.jruby.RubyMath.cosh19", "cosh");
            runtime.addBoundMethod("org.jruby.RubyMath.tanh19", "tanh");
            runtime.addBoundMethod("org.jruby.RubyMath.sqrt19", "sqrt");
            runtime.addBoundMethod("org.jruby.RubyMath.ldexp19", "ldexp");
            runtime.addBoundMethod("org.jruby.RubyMath.atan19", "atan");
            runtime.addBoundMethod("org.jruby.RubyMath.erfc19", "erfc");
            runtime.addBoundMethod("org.jruby.RubyMath.frexp19", "frexp");
            runtime.addBoundMethod("org.jruby.RubyMath.asin19", "asin");
            runtime.addBoundMethod("org.jruby.RubyMath.acosh19", "acosh");
            runtime.addBoundMethod("org.jruby.RubyMath.log2_19", "log2");
            runtime.addBoundMethod("org.jruby.RubyMath.acos19", "acos");
            runtime.addBoundMethod("org.jruby.RubyMath.sin19", "sin");
            runtime.addBoundMethod("org.jruby.RubyMath.tan19", "tan");
            runtime.addBoundMethod("org.jruby.RubyMath.atanh_19", "atanh");
            runtime.addBoundMethod("org.jruby.RubyMath.atan219", "atan2");
            runtime.addBoundMethod("org.jruby.RubyMath.erf19", "erf");
            runtime.addBoundMethod("org.jruby.RubyMath.exp19", "exp");
            runtime.addBoundMethod("org.jruby.RubyMath.cbrt", "cbrt");
            runtime.addBoundMethod("org.jruby.RubyMath.hypot19", "hypot");
            runtime.addBoundMethod("org.jruby.RubyMath.cos19", "cos");
            runtime.addBoundMethod("org.jruby.RubyMath.lgamma", "lgamma");
            runtime.addBoundMethod("org.jruby.RubyMath.log10_19", "log10");
            runtime.addBoundMethod("org.jruby.RubyMath.sinh19", "sinh");
        }
    }
}
