// 
// Decompiled by Procyon v0.5.30
// 

package org.jruby.gen;

import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.Ruby;
import org.jruby.RubyClass;
import org.jruby.RubyThread$i$0$0$backtrace;
import org.jruby.RubyThread$i$0$0$kill_bang;
import org.jruby.RubyThread$i$0$0$wakeup;
import org.jruby.RubyThread$i$0$0$alive_p;
import org.jruby.RubyFixnum;
import org.jruby.RubyThread$i$0$0$priority;
import org.jruby.RubyThread$i$0$1$join;
import org.jruby.RubyThread$i$0$0$run;
import org.jruby.RubyThread$i$1$0$key_p;
import org.jruby.RubyThread$i$0$0$inspect;
import org.jruby.RubyThread$i$0$0$initialize;
import org.jruby.RubyThread$i$2$0$op_aset;
import org.jruby.RubyThread$i$0$3$raise;
import org.jruby.RubyThread$i$0$0$stop_p;
import org.jruby.RubyThread$i$0$0$status;
import org.jruby.RubyThread$i$1$0$op_aref;
import org.jruby.RubyThread$i$0$0$safe_level;
import org.jruby.RubyThread$i$1$0$abort_on_exception_set;
import org.jruby.RubyThread$i$1$0$priority_set;
import org.jruby.RubyThread$i$0$0$kill;
import org.jruby.RubyThread$i$0$0$abort_on_exception;
import org.jruby.RubyThread$i$0$0$group;
import org.jruby.RubyThread$i$0$0$value;
import org.jruby.RubyThread$i$0$0$keys;
import org.jruby.RubyThread$s$1$0$critical_set;
import org.jruby.RubyThread$s$0$0$critical;
import org.jruby.CompatVersion;
import org.jruby.RubyThread$s$0$0$s_exit;
import org.jruby.RubyThread$s$0$0$newInstance;
import org.jruby.RubyThread$s$0$0$pass;
import org.jruby.RubyThread$s$1$0$abort_on_exception_set_x;
import org.jruby.RubyThread$s$0$0$start;
import org.jruby.RubyThread$s$0$0$current;
import org.jruby.runtime.Block;
import org.jruby.RubyThread$s$1$0$kill;
import org.jruby.RubyBoolean;
import org.jruby.RubyThread$s$0$0$abort_on_exception_x;
import org.jruby.RubyThread$s$0$0$main;
import org.jruby.runtime.ThreadContext;
import org.jruby.RubyThread$s$0$0$stop;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.RubyArray;
import org.jruby.RubyThread;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.RubyThread$s$0$0$list;
import org.jruby.runtime.Visibility;
import org.jruby.RubyModule;
import org.jruby.anno.TypePopulator;

public class org$jruby$RubyThread$Populator extends TypePopulator
{
    public void populate(final RubyModule cls, final Class clazz) {
        final RubyClass singletonClass = cls.getSingletonClass();
        final CompatVersion compatVersion = cls.getRuntime().getInstanceConfig().getCompatVersion();
        final Ruby runtime = cls.getRuntime();
        JavaMethod javaMethod = new RubyThread$s$0$0$list(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "list", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "list", RubyArray.class, new Class[] { IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("list", javaMethod);
        javaMethod = new RubyThread$s$0$0$stop(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "stop", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "stop", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("stop", javaMethod);
        javaMethod = new RubyThread$s$0$0$main(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "main", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "main", RubyThread.class, new Class[] { IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("main", javaMethod);
        javaMethod = new RubyThread$s$0$0$abort_on_exception_x(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "abort_on_exception_x", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "abort_on_exception_x", RubyBoolean.class, new Class[] { IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("abort_on_exception", javaMethod);
        javaMethod = new RubyThread$s$1$0$kill(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "kill", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "kill", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class, Block.class }, true);
        singletonClass.addMethodAtBootTimeOnly("kill", javaMethod);
        javaMethod = new RubyThread$s$0$0$current(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "current", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "current", RubyThread.class, new Class[] { IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("current", javaMethod);
        javaMethod = new RubyThread$s$0$0$start(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "start", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "start", RubyThread.class, new Class[] { IRubyObject.class, IRubyObject[].class, Block.class }, true);
        singletonClass.addMethodAtBootTimeOnly("start", javaMethod);
        javaMethod = new RubyThread$s$1$0$abort_on_exception_set_x(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "abort_on_exception_set_x", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "abort_on_exception_set_x", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("abort_on_exception=", javaMethod);
        javaMethod = new RubyThread$s$0$0$pass(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "pass", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "pass", IRubyObject.class, new Class[] { IRubyObject.class }, true);
        singletonClass.addMethodAtBootTimeOnly("pass", javaMethod);
        javaMethod = new RubyThread$s$0$0$newInstance(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "newInstance", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "newInstance", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject[].class, Block.class }, true);
        singletonClass.addMethodAtBootTimeOnly("new", javaMethod);
        singletonClass.addMethodAtBootTimeOnly("fork", javaMethod);
        javaMethod = new RubyThread$s$0$0$s_exit(singletonClass, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "s_exit", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "s_exit", IRubyObject.class, new Class[] { IRubyObject.class, Block.class }, true);
        singletonClass.addMethodAtBootTimeOnly("s_exit", javaMethod);
        runtime.addBoundMethod("org.jruby.RubyThread.list", "list");
        runtime.addBoundMethod("org.jruby.RubyThread.stop", "stop");
        runtime.addBoundMethod("org.jruby.RubyThread.main", "main");
        runtime.addBoundMethod("org.jruby.RubyThread.abort_on_exception_x", "abort_on_exception");
        runtime.addBoundMethod("org.jruby.RubyThread.kill", "kill");
        runtime.addBoundMethod("org.jruby.RubyThread.current", "current");
        runtime.addBoundMethod("org.jruby.RubyThread.start", "start");
        runtime.addBoundMethod("org.jruby.RubyThread.abort_on_exception_set_x", "abort_on_exception=");
        runtime.addBoundMethod("org.jruby.RubyThread.pass", "pass");
        runtime.addBoundMethod("org.jruby.RubyThread.newInstance", "new");
        runtime.addBoundMethod("org.jruby.RubyThread.s_exit", "s_exit");
        if (compatVersion == CompatVersion.RUBY1_8 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyThread$s$0$0$critical(singletonClass, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "critical", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyThread.class, "critical", IRubyObject.class, new Class[] { IRubyObject.class }, true);
            singletonClass.addMethodAtBootTimeOnly("critical", javaMethod);
            javaMethod = new RubyThread$s$1$0$critical_set(singletonClass, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "critical_set", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyThread.class, "critical_set", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
            singletonClass.addMethodAtBootTimeOnly("critical=", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyThread.critical", "critical");
            runtime.addBoundMethod("org.jruby.RubyThread.critical_set", "critical=");
        }
        javaMethod = new RubyThread$i$0$0$keys(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "keys", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "keys", RubyArray.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("keys", javaMethod);
        javaMethod = new RubyThread$i$0$0$value(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "value", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "value", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("value", javaMethod);
        javaMethod = new RubyThread$i$0$0$group(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "group", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "group", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("group", javaMethod);
        javaMethod = new RubyThread$i$0$0$abort_on_exception(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "abort_on_exception", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "abort_on_exception", RubyBoolean.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("abort_on_exception", javaMethod);
        javaMethod = new RubyThread$i$0$0$kill(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "kill", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "kill", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("kill", javaMethod);
        cls.addMethodAtBootTimeOnly("exit", javaMethod);
        cls.addMethodAtBootTimeOnly("terminate", javaMethod);
        javaMethod = new RubyThread$i$1$0$priority_set(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "priority_set", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "priority_set", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("priority=", javaMethod);
        javaMethod = new RubyThread$i$1$0$abort_on_exception_set(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "abort_on_exception_set", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "abort_on_exception_set", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("abort_on_exception=", javaMethod);
        javaMethod = new RubyThread$i$0$0$safe_level(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "safe_level", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "safe_level", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("safe_level", javaMethod);
        javaMethod = new RubyThread$i$1$0$op_aref(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "op_aref", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "op_aref", IRubyObject.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("[]", javaMethod);
        javaMethod = new RubyThread$i$0$0$status(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "status", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "status", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("status", javaMethod);
        javaMethod = new RubyThread$i$0$0$stop_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "stop_p", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "stop_p", RubyBoolean.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("stop?", javaMethod);
        javaMethod = new RubyThread$i$0$3$raise(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "raise", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "raise", IRubyObject.class, new Class[] { IRubyObject[].class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("raise", javaMethod);
        javaMethod = new RubyThread$i$2$0$op_aset(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 2, "op_aset", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "op_aset", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("[]=", javaMethod);
        javaMethod = new RubyThread$i$0$0$initialize(cls, Visibility.PRIVATE);
        TypePopulator.populateMethod(javaMethod, -1, "initialize", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "initialize", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject[].class, Block.class }, false);
        cls.addMethodAtBootTimeOnly("initialize", javaMethod);
        javaMethod = new RubyThread$i$0$0$inspect(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "inspect", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "inspect", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("inspect", javaMethod);
        javaMethod = new RubyThread$i$1$0$key_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "key_p", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "key_p", RubyBoolean.class, new Class[] { IRubyObject.class }, false);
        cls.addMethodAtBootTimeOnly("key?", javaMethod);
        javaMethod = new RubyThread$i$0$0$run(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "run", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "run", IRubyObject.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("run", javaMethod);
        javaMethod = new RubyThread$i$0$1$join(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, -1, "join", false, CallConfiguration.FrameBacktraceScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "join", IRubyObject.class, new Class[] { IRubyObject[].class }, false);
        cls.addMethodAtBootTimeOnly("join", javaMethod);
        javaMethod = new RubyThread$i$0$0$priority(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "priority", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "priority", RubyFixnum.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("priority", javaMethod);
        javaMethod = new RubyThread$i$0$0$alive_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "alive_p", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "alive_p", RubyBoolean.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("alive?", javaMethod);
        javaMethod = new RubyThread$i$0$0$wakeup(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 0, "wakeup", false, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyThread.class, "wakeup", RubyThread.class, new Class[0], false);
        cls.addMethodAtBootTimeOnly("wakeup", javaMethod);
        runtime.addBoundMethod("org.jruby.RubyThread.keys", "keys");
        runtime.addBoundMethod("org.jruby.RubyThread.value", "value");
        runtime.addBoundMethod("org.jruby.RubyThread.group", "group");
        runtime.addBoundMethod("org.jruby.RubyThread.abort_on_exception", "abort_on_exception");
        runtime.addBoundMethod("org.jruby.RubyThread.kill", "kill");
        runtime.addBoundMethod("org.jruby.RubyThread.priority_set", "priority=");
        runtime.addBoundMethod("org.jruby.RubyThread.abort_on_exception_set", "abort_on_exception=");
        runtime.addBoundMethod("org.jruby.RubyThread.safe_level", "safe_level");
        runtime.addBoundMethod("org.jruby.RubyThread.op_aref", "[]");
        runtime.addBoundMethod("org.jruby.RubyThread.status", "status");
        runtime.addBoundMethod("org.jruby.RubyThread.stop_p", "stop?");
        runtime.addBoundMethod("org.jruby.RubyThread.raise", "raise");
        runtime.addBoundMethod("org.jruby.RubyThread.op_aset", "[]=");
        runtime.addBoundMethod("org.jruby.RubyThread.initialize", "initialize");
        runtime.addBoundMethod("org.jruby.RubyThread.inspect", "inspect");
        runtime.addBoundMethod("org.jruby.RubyThread.key_p", "key?");
        runtime.addBoundMethod("org.jruby.RubyThread.run", "run");
        runtime.addBoundMethod("org.jruby.RubyThread.join", "join");
        runtime.addBoundMethod("org.jruby.RubyThread.priority", "priority");
        runtime.addBoundMethod("org.jruby.RubyThread.alive_p", "alive?");
        runtime.addBoundMethod("org.jruby.RubyThread.wakeup", "wakeup");
        if (compatVersion == CompatVersion.RUBY1_8 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyThread$i$0$0$kill_bang(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "kill_bang", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyThread.class, "kill_bang", IRubyObject.class, new Class[0], false);
            cls.addMethodAtBootTimeOnly("kill!", javaMethod);
            cls.addMethodAtBootTimeOnly("exit!", javaMethod);
            cls.addMethodAtBootTimeOnly("terminate!", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyThread.kill_bang", "kill!");
        }
        if (compatVersion == CompatVersion.RUBY1_9 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyThread$i$0$0$backtrace(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 0, "backtrace", false, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyThread.class, "backtrace", IRubyObject.class, new Class[] { ThreadContext.class }, false);
            cls.addMethodAtBootTimeOnly("backtrace", javaMethod);
            runtime.addBoundMethod("org.jruby.RubyThread.backtrace", "backtrace");
        }
    }
}
