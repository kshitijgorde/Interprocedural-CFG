// 
// Decompiled by Procyon v0.5.30
// 

package org.jruby.gen;

import org.jruby.internal.runtime.methods.JavaMethod;
import org.jruby.Ruby;
import org.jruby.RubyClass;
import org.jruby.RubyFileTest$s$1$0$worldReadable;
import org.jruby.RubyFileTest$s$1$0$worldWritable;
import org.jruby.CompatVersion;
import org.jruby.RubyFileTest$s$1$0$directory_p;
import org.jruby.RubyFileTest$s$1$0$size;
import org.jruby.RubyFileTest$s$1$0$chardev_p;
import org.jruby.RubyFileTest$s$1$0$executable_p;
import org.jruby.RubyFileTest$s$1$0$pipe_p;
import org.jruby.RubyFileTest$s$1$0$sticky_p;
import org.jruby.RubyFileTest$s$1$0$owned_p;
import org.jruby.RubyFileTest$s$1$0$exist_p;
import org.jruby.RubyFileTest$s$1$0$size_p;
import org.jruby.RubyFileTest$s$2$0$identical_p;
import org.jruby.RubyFileTest$s$1$0$file_p;
import org.jruby.RubyFileTest$s$1$0$zero_p;
import org.jruby.runtime.ThreadContext;
import org.jruby.RubyFileTest$s$1$0$readable_p;
import org.jruby.RubyFileTest$s$1$0$grpowned_p;
import org.jruby.RubyFileTest$s$1$0$writable_p;
import org.jruby.RubyFileTest$s$1$0$blockdev_p;
import org.jruby.RubyFileTest$s$1$0$setgid_p;
import org.jruby.RubyFileTest$s$1$0$setuid_p;
import org.jruby.RubyFileTest$s$1$0$socket_p;
import org.jruby.RubyBoolean;
import org.jruby.RubyFileTest$s$1$0$symlink_p;
import org.jruby.internal.runtime.methods.DynamicMethod;
import org.jruby.runtime.builtin.IRubyObject;
import org.jruby.RubyFileTest;
import org.jruby.internal.runtime.methods.CallConfiguration;
import org.jruby.RubyFileTest$s$1$0$executable_real_p;
import org.jruby.runtime.Visibility;
import org.jruby.RubyModule;
import org.jruby.anno.TypePopulator;

public class org$jruby$RubyFileTest$Populator extends TypePopulator
{
    public void populate(final RubyModule cls, final Class clazz) {
        final RubyClass singletonClass = cls.getSingletonClass();
        final CompatVersion compatVersion = cls.getRuntime().getInstanceConfig().getCompatVersion();
        final Ruby runtime = cls.getRuntime();
        JavaMethod javaMethod = new RubyFileTest$s$1$0$executable_real_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "executable_real_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "executable_real_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("executable_real?", javaMethod);
        DynamicMethod moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("executable_real?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$symlink_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "symlink_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "symlink_p", RubyBoolean.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("symlink?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("symlink?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$socket_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "socket_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "socket_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("socket?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("socket?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$setuid_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "setuid_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "setuid_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("setuid?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("setuid?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$setgid_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "setgid_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "setgid_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("setgid?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("setgid?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$blockdev_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "blockdev_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "blockdev_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("blockdev?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("blockdev?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$writable_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "writable_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "writable_p", RubyBoolean.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("writable?", javaMethod);
        cls.addMethodAtBootTimeOnly("writable_real?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("writable?", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("writable_real?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$grpowned_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "grpowned_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "grpowned_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("grpowned?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("grpowned?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$readable_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "readable_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "readable_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("readable?", javaMethod);
        cls.addMethodAtBootTimeOnly("readable_real?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("readable?", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("readable_real?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$zero_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "zero_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "zero_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("zero?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("zero?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$file_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "file_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "file_p", RubyBoolean.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("file?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("file?", moduleMethod);
        javaMethod = new RubyFileTest$s$2$0$identical_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 2, "identical_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "identical_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("identical?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("identical?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$size_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "size_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "size_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("size?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("size?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$exist_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "exist_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "exist_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("exist?", javaMethod);
        cls.addMethodAtBootTimeOnly("exists?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("exist?", moduleMethod);
        singletonClass.addMethodAtBootTimeOnly("exists?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$owned_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "owned_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "owned_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("owned?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("owned?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$sticky_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "sticky_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "sticky_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("sticky?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("sticky?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$pipe_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "pipe_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "pipe_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("pipe?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("pipe?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$executable_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "executable_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "executable_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("executable?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("executable?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$chardev_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "chardev_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "chardev_p", IRubyObject.class, new Class[] { IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("chardev?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("chardev?", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$size(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "size", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "size", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("size", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("size", moduleMethod);
        javaMethod = new RubyFileTest$s$1$0$directory_p(cls, Visibility.PUBLIC);
        TypePopulator.populateMethod(javaMethod, 1, "directory_p", true, CallConfiguration.FrameNoneScopeNone, false);
        javaMethod.setNativeCall(RubyFileTest.class, "directory_p", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
        cls.addMethodAtBootTimeOnly("directory?", javaMethod);
        moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
        singletonClass.addMethodAtBootTimeOnly("directory?", moduleMethod);
        runtime.addBoundMethod("org.jruby.RubyFileTest.executable_real_p", "executable_real?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.symlink_p", "symlink?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.socket_p", "socket?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.setuid_p", "setuid?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.setgid_p", "setgid?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.blockdev_p", "blockdev?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.writable_p", "writable?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.grpowned_p", "grpowned?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.readable_p", "readable?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.zero_p", "zero?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.file_p", "file?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.identical_p", "identical?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.size_p", "size?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.exist_p", "exist?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.owned_p", "owned?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.sticky_p", "sticky?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.pipe_p", "pipe?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.executable_p", "executable?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.chardev_p", "chardev?");
        runtime.addBoundMethod("org.jruby.RubyFileTest.size", "size");
        runtime.addBoundMethod("org.jruby.RubyFileTest.directory_p", "directory?");
        if (compatVersion == CompatVersion.RUBY1_9 || compatVersion == CompatVersion.BOTH) {
            javaMethod = new RubyFileTest$s$1$0$worldWritable(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "worldWritable", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyFileTest.class, "worldWritable", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("world_writable?", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("world_writable?", moduleMethod);
            javaMethod = new RubyFileTest$s$1$0$worldReadable(cls, Visibility.PUBLIC);
            TypePopulator.populateMethod(javaMethod, 1, "worldReadable", true, CallConfiguration.FrameNoneScopeNone, false);
            javaMethod.setNativeCall(RubyFileTest.class, "worldReadable", IRubyObject.class, new Class[] { ThreadContext.class, IRubyObject.class, IRubyObject.class }, true);
            cls.addMethodAtBootTimeOnly("world_readable?", javaMethod);
            moduleMethod = TypePopulator.populateModuleMethod(cls, javaMethod);
            singletonClass.addMethodAtBootTimeOnly("world_readable?", moduleMethod);
            runtime.addBoundMethod("org.jruby.RubyFileTest.worldWritable", "world_writable?");
            runtime.addBoundMethod("org.jruby.RubyFileTest.worldReadable", "world_readable?");
        }
    }
}
